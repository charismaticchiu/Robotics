<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Aria: ArFunctor Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>ArFunctor Class Reference</h1><code>#include &lt;ArFunctor.h&gt;</code>
<p>
<p>Inheritance diagram for ArFunctor:
<p><center><img src="classArFunctor.png" usemap="#ArFunctor_map" border="0" alt=""></center>
<map name="ArFunctor_map">
<area href="classArConstFunctorC.html" alt="ArConstFunctorC< T >" shape="rect" coords="0,56,187,80">
<area href="classArFunctor1.html" alt="ArFunctor1< P1 >" shape="rect" coords="197,56,384,80">
<area href="classArFunctor1.html" alt="ArFunctor1< const char * >" shape="rect" coords="591,56,778,80">
<area href="classArFunctorC.html" alt="ArFunctorC< T >" shape="rect" coords="788,56,975,80">
<area href="classArGlobalFunctor.html" alt="ArGlobalFunctor" shape="rect" coords="985,56,1172,80">
<area href="classArRetFunctor.html" alt="ArRetFunctor< Ret >" shape="rect" coords="1182,56,1369,80">
<area href="classArConstFunctor1C.html" alt="ArConstFunctor1C< T, P1 >" shape="rect" coords="394,112,581,136">
<area href="classArFunctor1C.html" alt="ArFunctor1C< T, P1 >" shape="rect" coords="394,168,581,192">
<area href="classArFunctor2.html" alt="ArFunctor2< P1, P2 >" shape="rect" coords="394,224,581,248">
<area href="classArGlobalFunctor1.html" alt="ArGlobalFunctor1< P1 >" shape="rect" coords="394,280,581,304">
<area href="classArMapFileLineSetWriter.html" alt="ArMapFileLineSetWriter" shape="rect" coords="591,112,778,136">
<area href="classArConstRetFunctorC.html" alt="ArConstRetFunctorC< Ret, T >" shape="rect" coords="1379,112,1566,136">
<area href="classArGlobalRetFunctor.html" alt="ArGlobalRetFunctor< Ret >" shape="rect" coords="1379,168,1566,192">
<area href="classArRetFunctor1.html" alt="ArRetFunctor1< Ret, P1 >" shape="rect" coords="1379,224,1566,248">
<area href="classArRetFunctorC.html" alt="ArRetFunctorC< Ret, T >" shape="rect" coords="1379,280,1566,304">
</map>
<a href="classArFunctor-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
Base class for functors. 
<p>
Functors are meant to encapsulate the idea of a pointer to a function which is a member of a class. To use a pointer to a member function, you must have a C style function pointer, 'void(Class::*)()', and a pointer to an instance of the class in which the function is a member of. This is because all non-static member functions must have a 'this' pointer. If they dont and if the member function uses any member data or even other member functions it will not work right and most likely crash. This is because the 'this' pointer is not the correct value and is most likely a random uninitialized value. The virtue of static member functions is that they do not require a 'this' pointer to be run. But the compiler will never let you access any member data or functions from within a static member function.<p>
Because of the design of C++ never allowed for encapsulating these two pointers together into one language supported construct, this has to be done by hand. For conviences sake, there are functors (<a class="el" href="classArGlobalFunctor.html">ArGlobalFunctor</a>, <a class="el" href="classArGlobalRetFunctor.html">ArGlobalRetFunctor</a>) which take a pure C style function pointer (a non-member function). This is in case you want to use a functor that refers to a global C style function.<p>
<a class="el" href="classAria.html">Aria</a> makes use of functors by using them as callback functions. Since <a class="el" href="classAria.html">Aria</a> is programmed using the object oriented programming paradigm, all the callback functions need to be tied to an object and a particular instance. Thus the need for functors. Most of the use of callbacks simply take an ArFunctor, which is the base class for all the functors. This class only has the ability to invoke a functor. All the derivitave functors have the ability to invoke the correct function on the correct object.<p>
Because functions have different signatures because they take different types of parameters and have different number of parameters, templates were used to create the functors. These are the base classes for the functors. These classes encapsulate everything except for the class type that the member function is a member of. This allows someone to accept a functor of type <a class="el" href="classArFunctor1.html">ArFunctor1&lt;int&gt;</a> which has one parameter of type 'int'. But they never have to know that the function is a member function of class 'SomeUnknownType'. These classes are:<p>
ArFunctor, <a class="el" href="classArFunctor1.html">ArFunctor1</a>, <a class="el" href="classArFunctor2.html">ArFunctor2</a>, <a class="el" href="classArFunctor3.html">ArFunctor3</a> <a class="el" href="classArRetFunctor.html">ArRetFunctor</a>, <a class="el" href="classArRetFunctor1.html">ArRetFunctor1</a>, <a class="el" href="classArRetFunctor2.html">ArRetFunctor2</a>, <a class="el" href="classArRetFunctor3.html">ArRetFunctor3</a><p>
These 8 functors are the only thing a piece of code that wants a functor will ever need. But these classes are abstract classes and can not be instantiated. On the other side, the piece of code that wants to be called back will need the functor classes that know about the class type. These functors are:<p>
<a class="el" href="classArFunctorC.html">ArFunctorC</a>, <a class="el" href="classArFunctor1C.html">ArFunctor1C</a>, <a class="el" href="classArFunctor2C.html">ArFunctor2C</a>, <a class="el" href="classArFunctor3C.html">ArFunctor3C</a> <a class="el" href="classArRetFunctorC.html">ArRetFunctorC</a>, <a class="el" href="classArRetFunctor1C.html">ArRetFunctor1C</a>, <a class="el" href="classArRetFunctor2C.html">ArRetFunctor2C</a>, <a class="el" href="classArRetFunctor3C.html">ArRetFunctor3C</a><p>
These functors are meant to be instantiated and passed of to a piece of code that wants to use them. That piece of code should only know the functor as one of the functor classes without the 'C' in it.<p>
Note that you can create these FunctorC instances with default arguments that are then used when the invoke is called without those arguments... These are quite useful since if you have a class that expects an ArFunctor you can make an <a class="el" href="classArFunctor1C.html">ArFunctor1C</a> with default arguments and pass it as an ArFunctor... and it will get called with that default argument, this is useful for having multiple functors use the same function with different arguments and results (just takes one functor each).<p>
Functors now have a <a class="el" href="classArFunctor.html#a0">getName()</a> method, this is useful as an aid to debugging, allowing you to display the name of some functor being used.<p>
<b>Java Wrapper Library:</b> You can subclass ArFunctor and override <a class="el" href="classArFunctor.html#a1">invoke()</a>.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="functorExample_8cpp-example.html">functorExample::cpp</a> </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>

<p>
<a class="el" href="functorExample_8cpp-example.html#_a267">functorExample.cpp</a>.</dl>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0" doxytag="ArFunctor::getName"></a>
virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFunctor.html#a0">getName</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the name of the functor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a1" doxytag="ArFunctor::invoke"></a>
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFunctor.html#a1">invoke</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invokes the functor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2" doxytag="ArFunctor::setName"></a>
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFunctor.html#a2">setName</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the name of the functor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFunctor.html#a3">setNameVar</a> (const char *name,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the name of the functor with formatting.  <a href="#a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4" doxytag="ArFunctor::~ArFunctor"></a>
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArFunctor.html#a4">~ArFunctor</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p0" doxytag="ArFunctor::myName"></a>
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>myName</b></td></tr>

</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a3" doxytag="ArFunctor::setNameVar"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual void ArFunctor::setNameVar           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>...</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the name of the functor with formatting. 
<p>
<b>Java and Python Wrappers:</b> Not available in Java or Python wrapper libraries. use <a class="el" href="classArFunctor.html#a2">setName()</a>     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li>ArFunctor.h</ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jan 7 10:34:41 2010 for Aria by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
