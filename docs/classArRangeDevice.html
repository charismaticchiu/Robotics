<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Aria: ArRangeDevice Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>ArRangeDevice Class Reference</h1><code>#include &lt;ArRangeDevice.h&gt;</code>
<p>
<p>Inheritance diagram for ArRangeDevice:
<p><center><img src="classArRangeDevice.png" usemap="#ArRangeDevice_map" border="0" alt=""></center>
<map name="ArRangeDevice_map">
<area href="classArBumpers.html" alt="ArBumpers" shape="rect" coords="0,56,160,80">
<area href="classArForbiddenRangeDevice.html" alt="ArForbiddenRangeDevice" shape="rect" coords="170,56,330,80">
<area href="classArIrrfDevice.html" alt="ArIrrfDevice" shape="rect" coords="340,56,500,80">
<area href="classArIRs.html" alt="ArIRs" shape="rect" coords="510,56,670,80">
<area href="classArLaserReflectorDevice.html" alt="ArLaserReflectorDevice" shape="rect" coords="680,56,840,80">
<area href="classArRangeDeviceThreaded.html" alt="ArRangeDeviceThreaded" shape="rect" coords="850,56,1010,80">
<area href="classArSonarDevice.html" alt="ArSonarDevice" shape="rect" coords="1020,56,1180,80">
<area href="classArLaser.html" alt="ArLaser" shape="rect" coords="850,112,1010,136">
<area href="classArLaserFilter.html" alt="ArLaserFilter" shape="rect" coords="510,168,670,192">
<area href="classArLMS1XX.html" alt="ArLMS1XX" shape="rect" coords="680,168,840,192">
<area href="classArLMS2xx.html" alt="ArLMS2xx" shape="rect" coords="850,168,1010,192">
<area href="classArSimulatedLaser.html" alt="ArSimulatedLaser" shape="rect" coords="1020,168,1180,192">
<area href="classArUrg.html" alt="ArUrg" shape="rect" coords="1190,168,1350,192">
</map>
<a href="classArRangeDevice-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
The base class for all sensing devices which return range information from the device (mounted on a robot) to an object in the environment. 
<p>
This class maintains two <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a> objects: a current buffer for storing very recent readings, and a cumulative buffer for a longer history of readings. The maximum sizes of each buffer can be set in the constructor or resized later. Range device readings are most often represented as a point in space (X,Y) where the sensor detected an object. (Therefore an <a class="el" href="classArPose.html">ArPose</a> object may only have X and Y components set). Some devices provide extra information in a "raw" buffer, or in lists of more detailed ArSensoReading objects.<p>
Subclasses are used for specific sensor implementations like ArSick for SICK lasers and <a class="el" href="classArSonarDevice.html">ArSonarDevice</a> for the Pioneer sonar array. It can also be useful to treat "virtual" objects like forbidden areas specified by the user in a map like range devices. Some of these subsclasses may use a separate thread to update the range reading buffers, and so this base class provides "lock" and "unlock" methods which you should use when accessing device data.<p>
A range device may have an <a class="el" href="classArRobot.html">ArRobot</a> object associated with it. A range device may also be associated with an <a class="el" href="classArRobot.html">ArRobot</a> by calling <a class="el" href="classArRobot.html#a8">ArRobot::addRangeDevice()</a>. <a class="el" href="classArRobot.html">ArRobot</a> provides functions which operate on all such associated ArRangeDevice objects. This is a convenient (and thread-safe) way to access all range device data without depending on a specific set of individual range devices. For example, you can find the closest reading in a box or a polar section, no matter if that reading originated from the sonar, a laser, or other device. <dl compact><dt><b>Examples: </b></dt><dd>

<p>
<a class="el" href="actionExample_8cpp-example.html#_a3">actionExample.cpp</a>.</dl>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0" doxytag="ArRangeDevice::addReading"></a>
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a0">addReading</a> (double x, double y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a reading to the buffer. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a1">applyTransform</a> (<a class="el" href="classArTransform.html">ArTransform</a> trans, bool doCumulative=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies a transform to the buffers.  <a href="#a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a2">ArRangeDevice</a> (size_t currentBufferSize, size_t cumulativeBufferSize, const char *name, unsigned int maxRange, int maxSecondsToKeepCurrent=0, int maxSecondsToKeepCumulative=0, double maxDistToKeepCumulative=0, bool locationDependent=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3" doxytag="ArRangeDevice::clearCumulativeOlderThan"></a>
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a3">clearCumulativeOlderThan</a> (int milliSeconds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears all the cumulative readings older than this number of milliseconds. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4" doxytag="ArRangeDevice::clearCumulativeOlderThanSeconds"></a>
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a4">clearCumulativeOlderThanSeconds</a> (int seconds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears all the cumulative readings older than this number of seconds. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5" doxytag="ArRangeDevice::clearCumulativeReadings"></a>
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a5">clearCumulativeReadings</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears all the cumulative readings. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6" doxytag="ArRangeDevice::clearCurrentReadings"></a>
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a6">clearCurrentReadings</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears all the current readings. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a7">cumulativeReadingBox</a> (double x1, double y1, double x2, double y2, <a class="el" href="classArPose.html">ArPose</a> *readingPos=NULL) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the closest current reading from the given box region.  <a href="#a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a8">cumulativeReadingPolar</a> (double startAngle, double endAngle, double *angle=NULL) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the closest cumulative reading in the given polar region.  <a href="#a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a9">currentReadingBox</a> (double x1, double y1, double x2, double y2, <a class="el" href="classArPose.html">ArPose</a> *readingPos=NULL) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the closest current reading from the given box region.  <a href="#a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a10">currentReadingPolar</a> (double startAngle, double endAngle, double *angle=NULL) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the closest current reading in the given polar region.  <a href="#a10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const std::list&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a11">getAdjustedRawReadings</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the raw unfiltered readings from the device (but pose takens are corrected).  <a href="#a11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::vector&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a12">getAdjustedRawReadingsAsVector</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the raw adjusted readings from the device into a vector.  <a href="#a12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a13" doxytag="ArRangeDevice::getCumulativeBuffer"></a>
virtual std::list&lt; <a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a13">getCumulativeBuffer</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current buffer of readings. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const std::list&lt; <a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a14">getCumulativeBuffer</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current buffer of readings.  <a href="#a14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::vector&lt; <a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a15">getCumulativeBufferAsVector</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the cumulative buffer of readings as a vector.  <a href="#a15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a16" doxytag="ArRangeDevice::getCumulativeDrawingData"></a>
virtual <a class="el" href="classArDrawingData.html">ArDrawingData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a16">getCumulativeDrawingData</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets data used for visualizing the cumulative buffer (see ArNetworking). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a17" doxytag="ArRangeDevice::getCumulativeRangeBuffer"></a>
virtual <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a17">getCumulativeRangeBuffer</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the cumulative range buffer. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a18">getCumulativeRangeBuffer</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the cumulative range buffer.  <a href="#a18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a19" doxytag="ArRangeDevice::getCurrentBuffer"></a>
virtual std::list&lt; <a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a19">getCurrentBuffer</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current buffer of readings. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const std::list&lt; <a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a20">getCurrentBuffer</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current buffer of readings.  <a href="#a20"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::vector&lt; <a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a21">getCurrentBufferAsVector</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current buffer of readings as a vector.  <a href="#a21"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a22" doxytag="ArRangeDevice::getCurrentDrawingData"></a>
virtual <a class="el" href="classArDrawingData.html">ArDrawingData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a22">getCurrentDrawingData</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets data used for visualizing the current buffer (see ArNetworking). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a23" doxytag="ArRangeDevice::getCurrentRangeBuffer"></a>
virtual <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a23">getCurrentRangeBuffer</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current range buffer. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a24">getCurrentRangeBuffer</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current range buffer.  <a href="#a24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a25">getMaxDistToKeepCumulative</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets the maximum distance cumulative readings can be from current pose  <a href="#a25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a26">getMaxInsertDistCumulative</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the maximum distance a cumulative reading can be from the robot and still be inserted.  <a href="#a26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a27" doxytag="ArRangeDevice::getMaxRange"></a>
virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a27">getMaxRange</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the maximum range for this device. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a28">getMaxSecondsToKeepCumulative</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">gets the maximum seconds to keep current readings around  <a href="#a28"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a29">getMaxSecondsToKeepCurrent</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">gets the maximum seconds to keep current readings around  <a href="#a29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a30">getMinDistBetweenCumulative</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the minimum distance between cumulative readings.  <a href="#a30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a31">getMinDistBetweenCurrent</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the minimum distance between current readings.  <a href="#a31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a32" doxytag="ArRangeDevice::getName"></a>
virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a32">getName</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the name of the device. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const std::list&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a33">getRawReadings</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the raw unfiltered readings from the device.  <a href="#a33"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual std::vector&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a34">getRawReadingsAsVector</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the raw unfiltered readings from the device into a vector.  <a href="#a34"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a35" doxytag="ArRangeDevice::getRobot"></a>
virtual <a class="el" href="classArRobot.html">ArRobot</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a35">getRobot</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the robot this device is attached to. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a36" doxytag="ArRangeDevice::isLocationDependent"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a36">isLocationDependent</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets if this device is location dependent or not. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a37" doxytag="ArRangeDevice::lockDevice"></a>
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a37">lockDevice</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock this device. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a38">setCumulativeBufferSize</a> (size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum size of the buffer for cumulative readings.  <a href="#a38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a39" doxytag="ArRangeDevice::setCumulativeDrawingData"></a>
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a39">setCumulativeDrawingData</a> (<a class="el" href="classArDrawingData.html">ArDrawingData</a> *data, bool takeOwnershipOfData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets data for visualizing the cumulative buffer (and if we own it). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a40">setCurrentBufferSize</a> (size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum size of the buffer for current readings.  <a href="#a40"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a41" doxytag="ArRangeDevice::setCurrentDrawingData"></a>
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a41">setCurrentDrawingData</a> (<a class="el" href="classArDrawingData.html">ArDrawingData</a> *data, bool takeOwnershipOfData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets data for visualizing the current buffer (and if we own it). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a42">setMaxDistToKeepCumulative</a> (double maxDistToKeepCumulative)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sets the maximum distance cumulative readings can be from current pose  <a href="#a42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a43">setMaxInsertDistCumulative</a> (double maxInsertDistCumulative)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum distance a cumulative reading can be from the robot and still be inserted.  <a href="#a43"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a44" doxytag="ArRangeDevice::setMaxRange"></a>
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a44">setMaxRange</a> (unsigned int maxRange)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum range for this device. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a45">setMaxSecondsToKeepCumulative</a> (int maxSecondsToKeepCumulative)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">gets the maximum seconds to keep cumulative readings around  <a href="#a45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a46">setMaxSecondsToKeepCurrent</a> (int maxSecondsToKeepCurrent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the maximum seconds to keep current readings around.  <a href="#a46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a47">setMinDistBetweenCumulative</a> (double minDistBetweenCumulative)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the minimum distance between cumulative readings.  <a href="#a47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a48">setMinDistBetweenCurrent</a> (double minDistBetweenCurrent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the minimum distance between current readings.  <a href="#a48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a49" doxytag="ArRangeDevice::setRobot"></a>
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a49">setRobot</a> (<a class="el" href="classArRobot.html">ArRobot</a> *robot)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the robot this device is attached to. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a50" doxytag="ArRangeDevice::tryLockDevice"></a>
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a50">tryLockDevice</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Try to lock this device. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a51" doxytag="ArRangeDevice::unlockDevice"></a>
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a51">unlockDevice</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock this device. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a52" doxytag="ArRangeDevice::~ArRangeDevice"></a>
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#a52">~ArRangeDevice</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArRangeDevice.html#b0">adjustRawReadings</a> (bool interlaced)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b1" doxytag="ArRangeDevice::filterCallback"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>filterCallback</b> (void)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p0" doxytag="ArRangeDevice::myAdjustedRawReadings"></a>
std::list&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><b>myAdjustedRawReadings</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p1" doxytag="ArRangeDevice::myAdjustedRawReadingsVector"></a>
std::vector&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>myAdjustedRawReadingsVector</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p2" doxytag="ArRangeDevice::myCumulativeBuffer"></a>
<a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>myCumulativeBuffer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p3" doxytag="ArRangeDevice::myCumulativeDrawingData"></a>
<a class="el" href="classArDrawingData.html">ArDrawingData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>myCumulativeDrawingData</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p4" doxytag="ArRangeDevice::myCurrentBuffer"></a>
<a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>myCurrentBuffer</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p5" doxytag="ArRangeDevice::myCurrentDrawingData"></a>
<a class="el" href="classArDrawingData.html">ArDrawingData</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>myCurrentDrawingData</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p6" doxytag="ArRangeDevice::myDeviceMutex"></a>
<a class="el" href="classArMutex.html">ArMutex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>myDeviceMutex</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p7" doxytag="ArRangeDevice::myFilterCB"></a>
<a class="el" href="classArFunctorC.html">ArFunctorC</a>&lt; <a class="el" href="classArRangeDevice.html">ArRangeDevice</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>myFilterCB</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p8" doxytag="ArRangeDevice::myIsLocationDependent"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myIsLocationDependent</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p9" doxytag="ArRangeDevice::myMaxDistToKeepCumulative"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMaxDistToKeepCumulative</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p10" doxytag="ArRangeDevice::myMaxDistToKeepCumulativeSquared"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMaxDistToKeepCumulativeSquared</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p11" doxytag="ArRangeDevice::myMaxInsertDistCumulative"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMaxInsertDistCumulative</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p12" doxytag="ArRangeDevice::myMaxInsertDistCumulativePose"></a>
<a class="el" href="classArPose.html">ArPose</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMaxInsertDistCumulativePose</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p13" doxytag="ArRangeDevice::myMaxInsertDistCumulativeSquared"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMaxInsertDistCumulativeSquared</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p14" doxytag="ArRangeDevice::myMaxRange"></a>
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMaxRange</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p15" doxytag="ArRangeDevice::myMaxSecondsToKeepCumulative"></a>
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMaxSecondsToKeepCumulative</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p16" doxytag="ArRangeDevice::myMaxSecondsToKeepCurrent"></a>
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMaxSecondsToKeepCurrent</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p17" doxytag="ArRangeDevice::myMinDistBetweenCumulative"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMinDistBetweenCumulative</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p18" doxytag="ArRangeDevice::myMinDistBetweenCumulativeSquared"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMinDistBetweenCumulativeSquared</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p19" doxytag="ArRangeDevice::myMinDistBetweenCurrent"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMinDistBetweenCurrent</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p20" doxytag="ArRangeDevice::myMinDistBetweenCurrentSquared"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMinDistBetweenCurrentSquared</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p21" doxytag="ArRangeDevice::myName"></a>
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>myName</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p22" doxytag="ArRangeDevice::myOwnCumulativeDrawingData"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myOwnCumulativeDrawingData</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p23" doxytag="ArRangeDevice::myOwnCurrentDrawingData"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myOwnCurrentDrawingData</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p24" doxytag="ArRangeDevice::myRawReadings"></a>
std::list&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> * &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><b>myRawReadings</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p25" doxytag="ArRangeDevice::myRawReadingsVector"></a>
std::vector&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>myRawReadingsVector</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p26" doxytag="ArRangeDevice::myRobot"></a>
<a class="el" href="classArRobot.html">ArRobot</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>myRobot</b></td></tr>

</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a2" doxytag="ArRangeDevice::ArRangeDevice"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">ArRangeDevice::ArRangeDevice           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>currentBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>cumulativeBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxRange</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxSecondsToKeepCurrent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>maxSecondsToKeepCumulative</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>maxDistToKeepCumulative</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>locationDependent</em> = <code>false</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>currentBufferSize</em>&nbsp;</td><td>number of readings to store in the current buffer</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cumulativeBufferSize</em>&nbsp;</td><td>number of readings to store in the cumulative buffer</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the name of this device</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxRange</em>&nbsp;</td><td>the maximum range of this device. If the device can't find a reading in a specified section, it returns this maxRange</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxSecondsToKeepCurrent</em>&nbsp;</td><td>this is the number of seconds to keep current readings in the current buffer. If less than 0, then readings are not automatically removed based on time (but can be replaced or removed for other reasons).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxSecondsToKeepCumulative</em>&nbsp;</td><td>this is the number of seconds to keep cumulative readings in the cumulative buffer. If less than 0 then readings are not automatically based on time (but can be replaced or removed for other reasons).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxDistToKeepCumulative</em>&nbsp;</td><td>if cumulative readings are further than this distance from the current robot pose, then they are removed. If this is less than 0 they are not removed because of this</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locationDependent</em>&nbsp;</td><td>if the data in this range device is dependent on the robot's location or not... For instance, a laser would not be dependent on location, because it'll be correct in a relative manner, whereas forbidden lines are dependent on location, because if the robot isn't where it thinks it is then the forbidden lines will be avoided in the wrong spots... this is mainly just a flag for other things to use when deciding what range devices to avoid</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>planar</em>&nbsp;</td><td>if the range device is planar or not... planar range devices are ones like the Sick LMS200 that are only in one plane and and are all measured from a single point... Where you can use the beams of the current reading to filter out any cumulative readings that are close to the beam... these range devices need to simply build a set of raw readings and then call 'planarProcessReadings' for this filtering to work </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="b0" doxytag="ArRangeDevice::adjustRawReadings"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ArRangeDevice::adjustRawReadings           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">bool&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>interlaced</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [protected]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This call should be called by the range device every robot cycle before the range device makes new readings (and even if it isn't adding any that cycle)... it will adjust the raw readings by the robot odometry offset. The robot should be locked when this happens (which should be the case if you're doing it in the robot callback). The code currently assumes that all readings were taken at the same point, so if that isn't true with your device then you can't use this mechanism.     </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="ArRangeDevice::applyTransform"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ArRangeDevice::applyTransform           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classArTransform.html">ArTransform</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>trans</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>doCumulative</em> = <code>true</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Applies a transform to the buffers. 
<p>
Applies a coordinate transformation to some or all buffers. This is mostly useful for translating to/from local/global coordinate systems, but may have other uses. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>trans</em>&nbsp;</td><td>the transform to apply to the data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>doCumulative</em>&nbsp;</td><td>whether to transform the cumulative buffer or not </td></tr>
  </table>
</dl>

<p>
Reimplemented in <a class="el" href="classArLaser.html#a7">ArLaser</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="ArRangeDevice::cumulativeReadingBox"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double ArRangeDevice::cumulativeReadingBox           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>x1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classArPose.html">ArPose</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pose</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the closest current reading from the given box region. 
<p>
Get the closest reading in the cumulative buffer within a rectangular region around the range device, defined by two points (opposeite points of a rectangle). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x1</em>&nbsp;</td><td>the x coordinate of one of the rectangle points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y1</em>&nbsp;</td><td>the y coordinate of one of the rectangle points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x2</em>&nbsp;</td><td>the x coordinate of the other rectangle point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y2</em>&nbsp;</td><td>the y coordinate of the other rectangle point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pose</em>&nbsp;</td><td>a pointer to an <a class="el" href="classArPose.html">ArPose</a> object in which to store the location of the closest position </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The range to the reading from the device, or a value &gt;= maxRange if no reading was found in the box. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="ArRangeDevice::cumulativeReadingPolar"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double ArRangeDevice::cumulativeReadingPolar           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>startAngle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>endAngle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>angle</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the closest cumulative reading in the given polar region. 
<p>
The closest reading in this range device's cumulative buffer within a polar region or "slice" defined by the given angle range is returned. Optionally return the specific angle of the found reading as well. The region searched is the region between a starting angle, sweeping counter-clockwise to the ending angle (0 is straight ahead of the device, -90 to the right, 90 to the left). Note that there is a difference between the region (0, 10) and (10, 0). (0, 10) is a 10-degree span near the front of the device, while (10, 0) is a 350 degree span covering the sides and rear. Similarly, (-60, -30) covers 30 degrees on the right hand side, while (-30, -60) covers 330 degrees. In other words, if you want the smallest section between the two angles, ensure than startAngle &lt; endAngle. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startAngle</em>&nbsp;</td><td>where to start the slice </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endAngle</em>&nbsp;</td><td>where to end the slice, going counterclockwise from startAngle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>if given, a pointer to a value in which to put the specific angle to the found reading </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the range to the obstacle (a value &gt;= the maximum range indicates that no reading was detected in the specified region)</dd></dl>
Example: <div align="center">
<img src="ArRangeDevice_currentReadingPolar.png" alt="ArRangeDevice_currentReadingPolar.png">
<p><strong>This figure illustrates an example range device and the meanings of arguments and return value.</strong></p></div>
     </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="ArRangeDevice::currentReadingBox"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double ArRangeDevice::currentReadingBox           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>x1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="classArPose.html">ArPose</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pose</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the closest current reading from the given box region. 
<p>
Get the closest reading in the current buffer within a rectangular region defined by two points (opposite corners of the rectangle). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x1</em>&nbsp;</td><td>the x coordinate of one of the rectangle points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y1</em>&nbsp;</td><td>the y coordinate of one of the rectangle points </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x2</em>&nbsp;</td><td>the x coordinate of the other rectangle point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y2</em>&nbsp;</td><td>the y coordinate of the other rectangle point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pose</em>&nbsp;</td><td>a pointer to an <a class="el" href="classArPose.html">ArPose</a> object in which to store the location of the closest position </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The range to the reading from the device, or a value &gt;= maxRange if no reading was found in the box. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="ArRangeDevice::currentReadingPolar"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double ArRangeDevice::currentReadingPolar           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>startAngle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>endAngle</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>angle</em> = <code>NULL</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the closest current reading in the given polar region. 
<p>
The closest reading within a polar region or "slice" defined by the given angle range is returned. Optionally, the specific angle of the found may be placed in <em>angle</em>, if not NULL. The region searched is the region between <em>startAngle</em>, sweeping counter-clockwise to <em>endAngle</em> (0 is straight ahead of the device, -90 to the right, 90 to the left). Note that therefore there is a difference between e.g. the regions (0, 10) and (10, 0). (0, 10) is a 10-degree span near the front of the device, while (10, 0) is a 350 degree span covering the sides and rear. Similarly, (-60, -30) covers 30 degrees on the right hand side, while (-30, -60) covers 330 degrees. (-90, 90) is 180 degrees in front. (-180, 180) covers all sides of the robot. In other words, if you want the smallest section between the two angles, ensure that <em>startAngle</em> &lt; <em>endAngle</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startAngle</em>&nbsp;</td><td>where to start the slice </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>endAngle</em>&nbsp;</td><td>where to end the slice, going counterclockwise from startAngle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>if given, a pointer to a value in which to put the specific angle to the found reading </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the range to the obstacle (a value &gt;= the maximum range indicates that no reading was detected in the specified region)</dd></dl>
Example: <div align="center">
<img src="ArRangeDevice_currentReadingPolar.png" alt="ArRangeDevice_currentReadingPolar.png">
<p><strong>This figure illustrates an example range device and the meanings of arguments and return value.</strong></p></div>
     </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="ArRangeDevice::getAdjustedRawReadings"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const std::list&lt;<a class="el" href="classArSensorReading.html">ArSensorReading</a> *&gt;* ArRangeDevice::getAdjustedRawReadings           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the raw unfiltered readings from the device (but pose takens are corrected). 
<p>
The raw readings are the full set of unfiltered readings from the device. They are the latest readings. You should not manipulate the list you get from this function, the only manipulation of this list should be done by the range device itself. (Its only pointers for speed.)<p>
This is like the raw readings but they were corrected for the robot odometry offset (just the pose taken, and encoder psoe taken).<p>
<dl compact><dt><b>Note:</b></dt><dd>Only ArSick provides this data currently. Sonar, bumpers, etc. do not provide raw readings. This method was added to this base class for future lasers or other similar devices. Other kinds of range devices are sufficiently different from lasers that any "raw" information provided would usually require very different interpretation. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="ArRangeDevice::getAdjustedRawReadingsAsVector"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">std::vector&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> &gt; * ArRangeDevice::getAdjustedRawReadingsAsVector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the raw adjusted readings from the device into a vector. 
<p>
Copies the list into a vector. <p>
<b>Java and Python Wrappers:</b> The return type will be named ArSensorReadingVector instead of the std::vector template type.     </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="ArRangeDevice::getCumulativeBuffer"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const std::list&lt;<a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> *&gt;* ArRangeDevice::getCumulativeBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the current buffer of readings. 
<p>
<b>Java and Python Wrappers:</b> Not available in Java or Python wrapper libraries. See <a class="el" href="classArRangeDevice.html#a15">getCumulativeBufferAsVector()</a>     </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="ArRangeDevice::getCumulativeBufferAsVector"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual std::vector&lt;<a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a>&gt;* ArRangeDevice::getCumulativeBufferAsVector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the cumulative buffer of readings as a vector. 
<p>
<b>Java and Python Wrappers:</b> The return type will be named ArPoseWithTimeVector instead of the std::vector template.     </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="ArRangeDevice::getCumulativeRangeBuffer"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a>* ArRangeDevice::getCumulativeRangeBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the cumulative range buffer. 
<p>
<b>Java and Python Wrappers:</b> Not available in Java or Python wrapper libraries. See <a class="el" href="classArRangeDevice.html#a15">getCumulativeBufferAsVector()</a>     </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="ArRangeDevice::getCurrentBuffer"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const std::list&lt;<a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a> *&gt;* ArRangeDevice::getCurrentBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the current buffer of readings. 
<p>
<b>Java and Python Wrappers:</b> Not available in Java or Python wrapper libraries. See <a class="el" href="classArRangeDevice.html#a21">getCurrentBufferAsVector()</a>     </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="ArRangeDevice::getCurrentBufferAsVector"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual std::vector&lt;<a class="el" href="classArPoseWithTime.html">ArPoseWithTime</a>&gt;* ArRangeDevice::getCurrentBufferAsVector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the current buffer of readings as a vector. 
<p>
<b>Java and Python Wrappers:</b> The return type will be named ArPoseWithTimeVector instead of the std::vector template.     </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="ArRangeDevice::getCurrentRangeBuffer"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a>* ArRangeDevice::getCurrentRangeBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the current range buffer. 
<p>
<b>Java and Python Wrappers:</b> Not available in Java or Python wrapper libraries. See <a class="el" href="classArRangeDevice.html#a21">getCurrentBufferAsVector()</a>     </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="ArRangeDevice::getMaxDistToKeepCumulative"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double ArRangeDevice::getMaxDistToKeepCumulative           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
sets the maximum distance cumulative readings can be from current pose 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>if cumulative readings are further than this from where the current pose they are removed, if this is less than 0 they are not removed because of this </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="ArRangeDevice::getMaxInsertDistCumulative"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double ArRangeDevice::getMaxInsertDistCumulative           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the maximum distance a cumulative reading can be from the robot and still be inserted. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The maximum distance a cumulative reading can have from the robot's current position and still be inserted into the cumulative readings, this is applied in the addReading call so range devices need to call that for this to take effect. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="ArRangeDevice::getMaxSecondsToKeepCumulative"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int ArRangeDevice::getMaxSecondsToKeepCumulative           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
gets the maximum seconds to keep current readings around 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>this is the number of seconds cumulative readings are kept around for, if less than 0 then they are not automatically removed because of this </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="ArRangeDevice::getMaxSecondsToKeepCurrent"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int ArRangeDevice::getMaxSecondsToKeepCurrent           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
gets the maximum seconds to keep current readings around 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>this is the number of seconds current readings are kept around for, if less than 0 then they are not automatically removed because of this </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="ArRangeDevice::getMinDistBetweenCumulative"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double ArRangeDevice::getMinDistBetweenCumulative           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the minimum distance between cumulative readings. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The minimum distance between cumulative readings, this is applied in the addReading call so range devices need to call that for this to take effect. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a31" doxytag="ArRangeDevice::getMinDistBetweenCurrent"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">double ArRangeDevice::getMinDistBetweenCurrent           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the minimum distance between current readings. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The minimum distance between current readings, this is applied in the addReading call so range devices need to call that for this to take effect. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a33" doxytag="ArRangeDevice::getRawReadings"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const std::list&lt;<a class="el" href="classArSensorReading.html">ArSensorReading</a> *&gt;* ArRangeDevice::getRawReadings           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the raw unfiltered readings from the device. 
<p>
The raw readings are the full set of unfiltered readings from the device. They are the latest readings. You should not manipulate the list you get from this function, the only manipulation of this list should be done by the range device itself. (Its only pointers for speed.)<p>
<dl compact><dt><b>Note:</b></dt><dd>Only ArSick provides this data currently. Sonar, bumpers, etc. do not provide raw readings. This method was added to this base class for future lasers or other similar devices. Other kinds of range devices are sufficiently different from lasers that any "raw" information provided would usually require very different interpretation. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a34" doxytag="ArRangeDevice::getRawReadingsAsVector"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">std::vector&lt; <a class="el" href="classArSensorReading.html">ArSensorReading</a> &gt; * ArRangeDevice::getRawReadingsAsVector           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets the raw unfiltered readings from the device into a vector. 
<p>
Copies the list into a vector. <p>
<b>Java and Python Wrappers:</b> The return type will be named ArSensorReadingVector instead of the std::vector template type.     </td>
  </tr>
</table>
<a class="anchor" name="a38" doxytag="ArRangeDevice::setCumulativeBufferSize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ArRangeDevice::setCumulativeBufferSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the maximum size of the buffer for cumulative readings. 
<p>
If the <em>size</em> is smaller than the cumulative buffer size, then the oldest readings are discarded, leaving only <em>size</em> newest readings. If <em>size</em> is larger than the cumulative buffer size, then the buffer size will be allowed to grow to that size as new readings are added. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>number of readings to set the buffer to </td></tr>
  </table>
</dl>

<p>
Reimplemented in <a class="el" href="classArLaser.html#a89">ArLaser</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a40" doxytag="ArRangeDevice::setCurrentBufferSize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ArRangeDevice::setCurrentBufferSize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the maximum size of the buffer for current readings. 
<p>
If the <em>size</em> is smaller than the current buffer size, then the oldest readings are discarded, leaving only <em>size</em> newest readings. If <em>size</em> is larger than the current size, then the buffer size will be allowed to grow to that size as new readings are added. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>number of readings to set the buffer's maximum size to </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a42" doxytag="ArRangeDevice::setMaxDistToKeepCumulative"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ArRangeDevice::setMaxDistToKeepCumulative           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>maxDistToKeepCumulative</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
sets the maximum distance cumulative readings can be from current pose 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxDistToKeepCumulative</em>&nbsp;</td><td>if cumulative readings are further than this from where the current pose they are removed, if this is less than 0 they are not removed because of this </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a43" doxytag="ArRangeDevice::setMaxInsertDistCumulative"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ArRangeDevice::setMaxInsertDistCumulative           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>maxInsertDistCumulative</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the maximum distance a cumulative reading can be from the robot and still be inserted. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxInsertDistCumulative</em>&nbsp;</td><td>The maximum distance a cumulative reading can have from the robot's current position and still be inserted into the cumulative readings, this is applied in the addReading call so range devices need to call that for this to take effect. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a45" doxytag="ArRangeDevice::setMaxSecondsToKeepCumulative"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ArRangeDevice::setMaxSecondsToKeepCumulative           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>maxSecondsToKeepCumulative</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
gets the maximum seconds to keep cumulative readings around 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxSecondsToKeepCumulative</em>&nbsp;</td><td>this is the number of seconds to keep cumulative readings around, if less than 0 then they are not automatically removed because of this </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a46" doxytag="ArRangeDevice::setMaxSecondsToKeepCurrent"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ArRangeDevice::setMaxSecondsToKeepCurrent           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>maxSecondsToKeepCurrent</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the maximum seconds to keep current readings around. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>maxSecondsToKeepCurrent</em>&nbsp;</td><td>this is the number of seconds to keep current readings around, if less than 0 then they are not automatically removed because of this </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a47" doxytag="ArRangeDevice::setMinDistBetweenCumulative"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ArRangeDevice::setMinDistBetweenCumulative           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>minDistBetweenCumulative</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the minimum distance between cumulative readings. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minDistBetweenCumulative</em>&nbsp;</td><td>The minimum distance between cumulative readings, this is applied in the addReading call so range devices need to call that for this to take effect. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a48" doxytag="ArRangeDevice::setMinDistBetweenCurrent"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ArRangeDevice::setMinDistBetweenCurrent           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>minDistBetweenCurrent</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the minimum distance between current readings. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minDistBetweenCurrent</em>&nbsp;</td><td>The minimum distance between current readings, this is applied in the addReading call so range devices need to call that for this to take effect. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li>ArRangeDevice.h<li>ArRangeDevice.cpp</ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jan 7 10:34:43 2010 for Aria by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
