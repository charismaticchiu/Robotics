<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Aria: ArThread Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>ArThread Class Reference</h1><code>#include &lt;ArThread.h&gt;</code>
<p>
<p>Inheritance diagram for ArThread:
<p><center><img src="classArThread.png" usemap="#ArThread_map" border="0" alt=""></center>
<map name="ArThread_map">
<area href="classArASyncTask.html" alt="ArASyncTask" shape="rect" coords="216,56,350,80">
<area href="classArFunctorASyncTask.html" alt="ArFunctorASyncTask" shape="rect" coords="0,112,134,136">
<area href="classArRecurrentTask.html" alt="ArRecurrentTask" shape="rect" coords="144,112,278,136">
<area href="classArSignalHandler.html" alt="ArSignalHandler" shape="rect" coords="288,112,422,136">
<area href="classArSoundsQueue.html" alt="ArSoundsQueue" shape="rect" coords="432,112,566,136">
</map>
<a href="classArThread-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
POSIX/WIN32 thread wrapper class. 
<p>
<a class="el" href="classArThread.html#a4">create()</a> will create the thread. That thread will run the given Functor.<p>
A thread can either be in a detached state or a joinable state. If the thread is in a detached state, that thread can not be <a class="el" href="classArThread.html#a18">join()</a>'ed upon. The thread will simply run until the program exits, or its function exits. A joinable thread means that another thread and call <a class="el" href="classArThread.html#a18">join()</a> upon it. If this function is called, the caller will block until the thread exits its function. This gives a way to synchronize upon the lifespan of threads.<p>
Calling <a class="el" href="classArThread.html#a3">cancel()</a> will cancel the thread.<p>
The static function <a class="el" href="classArThread.html#e8">self()</a> will return a thread 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w0" doxytag="ArThread::MapType"></a>
typedef std::map&lt; ThreadType,<br>
 <a class="el" href="classArThread.html">ArThread</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>MapType</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#w1">Status</a> { <br>
&nbsp;&nbsp;<a class="el" href="classArThread.html#w1w3">STATUS_FAILED</a> = 1, 
<a class="el" href="classArThread.html#w1w7">STATUS_NORESOURCE</a>, 
<a class="el" href="classArThread.html#w1w6">STATUS_NO_SUCH_THREAD</a>, 
<a class="el" href="classArThread.html#w1w4">STATUS_INVALID</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="classArThread.html#w1w5">STATUS_JOIN_SELF</a>, 
<a class="el" href="classArThread.html#w1w2">STATUS_ALREADY_DETATCHED</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w8" doxytag="ArThread::ThreadType"></a>
typedef pthread_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>ThreadType</b></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0" doxytag="ArThread::ArThread"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a0">ArThread</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *func, bool joinable=true, bool blockAllSignals=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor - starts the thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a1" doxytag="ArThread::ArThread"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a1">ArThread</a> (ThreadType thread, bool joinable, bool blockAllSignals=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor - starts the thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2" doxytag="ArThread::ArThread"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a2">ArThread</a> (bool blockAllSignals=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3" doxytag="ArThread::cancel"></a>
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a3">cancel</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel the thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4" doxytag="ArThread::create"></a>
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a4">create</a> (<a class="el" href="classArFunctor.html">ArFunctor</a> *func, bool joinable=true, bool lowerPriority=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create and start the thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5" doxytag="ArThread::detach"></a>
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a5">detach</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detatch the thread so it cant be joined. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6" doxytag="ArThread::getBlockAllSignals"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a6">getBlockAllSignals</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Do we block all process signals at startup? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7" doxytag="ArThread::getFunc"></a>
virtual <a class="el" href="classArFunctor.html">ArFunctor</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a7">getFunc</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the functor that the thread runs. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8" doxytag="ArThread::getJoinable"></a>
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a8">getJoinable</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the joinable status of the thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a9" doxytag="ArThread::getOSThread"></a>
virtual ThreadType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a9">getOSThread</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the underlying os thread type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a10" doxytag="ArThread::getPID"></a>
pid_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>getPID</b> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a11" doxytag="ArThread::getRunning"></a>
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a11">getRunning</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the running status of the thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a12" doxytag="ArThread::getRunningWithLock"></a>
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a12">getRunningWithLock</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the running status of the thread, locking around the variable. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a13" doxytag="ArThread::getThread"></a>
virtual const ThreadType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a13">getThread</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the underlying thread type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a14">getThreadActivity</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a15" doxytag="ArThread::getThreadName"></a>
virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a15">getThreadName</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the name of the thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a16">isThreadFinished</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the thread has been completed and can be deleted.  <a href="#a16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a17">isThreadStarted</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the thread has been started.  <a href="#a17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a18" doxytag="ArThread::join"></a>
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a18">join</a> (void **ret=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Join on the thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a19">lock</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a20" doxytag="ArThread::logThreadInfo"></a>
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a20">logThreadInfo</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Logs the information about this thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a21" doxytag="ArThread::setRunning"></a>
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a21">setRunning</a> (bool running)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the running value on the thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a22" doxytag="ArThread::setThreadName"></a>
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a22">setThreadName</a> (const char *name)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the name of the thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a23" doxytag="ArThread::stopRunning"></a>
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a23">stopRunning</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop the thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a24">threadFinished</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks the thread as finished and logs useful debugging information.  <a href="#a24"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a25">threadStarted</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks the thread as started and logs useful debugging information.  <a href="#a25"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a26">tryLock</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a27">unlock</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a28" doxytag="ArThread::~ArThread"></a>
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#a28">~ArThread</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e0" doxytag="ArThread::cancelAll"></a>
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#e0">cancelAll</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancel all threads. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e1" doxytag="ArThread::getLogLevel"></a>
static <a class="el" href="classArLog.html#w2">ArLog::LogLevel</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#e1">getLogLevel</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the logging level for thread information. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e2" doxytag="ArThread::getThisOSThread"></a>
static ThreadType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#e2">getThisOSThread</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the underlying os thread type of this thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e3" doxytag="ArThread::getThisThread"></a>
static const ThreadType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#e3">getThisThread</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the underlying thread type of this thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e4" doxytag="ArThread::getThisThreadName"></a>
static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#e4">getThisThreadName</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the name of the this thread. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#e5">init</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the internal book keeping structures.  <a href="#e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e6" doxytag="ArThread::joinAll"></a>
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#e6">joinAll</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Join on all threads. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static ThreadType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#e7">osSelf</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the os self of the current thread.  <a href="#e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classArThread.html">ArThread</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#e8">self</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the instance of your own thread (the current one).  <a href="#e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e9" doxytag="ArThread::setLogLevel"></a>
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#e9">setLogLevel</a> (<a class="el" href="classArLog.html#w2">ArLog::LogLevel</a> level)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the logging level for thread information. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e10" doxytag="ArThread::stopAll"></a>
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#e10">stopAll</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop all threads. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e11" doxytag="ArThread::yieldProcessor"></a>
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#e11">yieldProcessor</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Yield the processor to another thread. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b0" doxytag="ArThread::doJoin"></a>
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><b>doJoin</b> (void **ret=NULL)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p0" doxytag="ArThread::myBlockAllSignals"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myBlockAllSignals</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p1" doxytag="ArThread::myFinished"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myFinished</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p2" doxytag="ArThread::myFunc"></a>
<a class="el" href="classArFunctor.html">ArFunctor</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>myFunc</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p3" doxytag="ArThread::myJoinable"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myJoinable</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p4" doxytag="ArThread::myMutex"></a>
<a class="el" href="classArMutex.html">ArMutex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>myMutex</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p5" doxytag="ArThread::myName"></a>
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>myName</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p6" doxytag="ArThread::myPID"></a>
pid_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>myPID</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p7" doxytag="ArThread::myRunning"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classArThread.html#p7">myRunning</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">State variable to denote when the thread should continue or exit. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p8" doxytag="ArThread::myStarted"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>myStarted</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p9" doxytag="ArThread::myStrMap"></a>
ArStrMap&nbsp;</td><td class="memItemRight" valign="bottom"><b>myStrMap</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p10" doxytag="ArThread::myThread"></a>
ThreadType&nbsp;</td><td class="memItemRight" valign="bottom"><b>myThread</b></td></tr>

<tr><td colspan="2"><br><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="t0" doxytag="ArThread::ourLogLevel"></a>
static <a class="el" href="classArLog.html#w2">ArLog::LogLevel</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>ourLogLevel</b> = ArLog::Verbose</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="t1" doxytag="ArThread::ourThreads"></a>
static MapType&nbsp;</td><td class="memItemRight" valign="bottom"><b>ourThreads</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="t2" doxytag="ArThread::ourThreadsMutex"></a>
static <a class="el" href="classArMutex.html">ArMutex</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>ourThreadsMutex</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="t3" doxytag="ArThread::ourUnknownThreadName"></a>
static std::string&nbsp;</td><td class="memItemRight" valign="bottom"><b>ourUnknownThreadName</b> = "unknown"</td></tr>

</table>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="w1" doxytag="ArThread::Status"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="classArThread.html#w1">ArThread::Status</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="w1w3" doxytag="STATUS_FAILED"></a>STATUS_FAILED</em>&nbsp;</td><td>
Failed to create the thread. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="w1w7" doxytag="STATUS_NORESOURCE"></a>STATUS_NORESOURCE</em>&nbsp;</td><td>
Not enough system resources to create the thread. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="w1w6" doxytag="STATUS_NO_SUCH_THREAD"></a>STATUS_NO_SUCH_THREAD</em>&nbsp;</td><td>
The thread can no longer be found. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="w1w4" doxytag="STATUS_INVALID"></a>STATUS_INVALID</em>&nbsp;</td><td>
Thread is detached or another thread is joining on it. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="w1w5" doxytag="STATUS_JOIN_SELF"></a>STATUS_JOIN_SELF</em>&nbsp;</td><td>
Thread is your own thread. Can't join on self. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="w1w2" doxytag="STATUS_ALREADY_DETATCHED"></a>STATUS_ALREADY_DETATCHED</em>&nbsp;</td><td>
Thread is already detatched. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a14" doxytag="ArThread::getThreadActivity"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual const char* ArThread::getThreadActivity           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Gets a string that describes what the thread is doing NULL if it doesn't know 
<p>
Reimplemented in <a class="el" href="classArASyncTask.html#a2">ArASyncTask</a>.    </td>
  </tr>
</table>
<a class="anchor" name="e5" doxytag="ArThread::init"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ArThread::init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize the internal book keeping structures. 
<p>
Initializes the internal structures which keep track of what thread is what. This is called by <a class="el" href="classAria.html#e23">Aria::init()</a>, so the user will not normaly need to call this function themselves. This funtion *must* be called from the main thread of the application. In otherwords, it should be called by main().     </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="ArThread::isThreadFinished"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool ArThread::isThreadFinished           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns whether the thread has been completed and can be deleted. 
<p>
This is dependent on the thread implementation calling the <a class="el" href="classArThread.html#a24">threadFinished()</a> method.     </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="ArThread::isThreadStarted"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">bool ArThread::isThreadStarted           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns whether the thread has been started. 
<p>
This is dependent on the thread implementation calling the <a class="el" href="classArThread.html#a25">threadStarted()</a> method.     </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="ArThread::lock"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int ArThread::lock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lock the thread instance <p>
<b>Java and Python Wrappers:</b> Not available in Java or Python wrapper libraries.     </td>
  </tr>
</table>
<a class="anchor" name="e7" doxytag="ArThread::osSelf"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">ArThread::ThreadType ArThread::osSelf           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the os self of the current thread. 
<p>
This returns the OS thread, and should be used in place of self if its being used a lot.     </td>
  </tr>
</table>
<a class="anchor" name="e8" doxytag="ArThread::self"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classArThread.html">ArThread</a> * ArThread::self           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns the instance of your own thread (the current one). 
<p>
If a newly created thread calls <a class="el" href="classArThread.html#e8">self()</a> on itself too soon, this will return NULL. This is due to the fact that the thread is first created and started. Then the operating system returns the thread ID and thread that called <a class="el" href="classArThread.html#a4">create()</a> then updates the list of threads with the new thread ID. There is just not much that can be done about that. The use should be aware of this caveat.<p>
Note that this does a lookup on the thread map, so it might be a little slow, if you need to use this a lot you should probably use osSelf instead.     </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="ArThread::threadFinished"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ArThread::threadFinished           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Marks the thread as finished and logs useful debugging information. 
<p>
This method should be called after the main thread loop ends. It enables the creator of the thread to determine that the thread has actually been completed and can be deleted.     </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="ArThread::threadStarted"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ArThread::threadStarted           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Marks the thread as started and logs useful debugging information. 
<p>
If you call this function in your functor (ie runThread) it'll then call some things for logging (to make debugging easier) This method should be called before the main thread loop begins.     </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="ArThread::tryLock"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int ArThread::tryLock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Try to lock the thread instance without blocking <p>
<b>Java and Python Wrappers:</b> Not available in Java or Python wrapper libraries.     </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="ArThread::unlock"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int ArThread::unlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unlock the thread instance <p>
<b>Java and Python Wrappers:</b> Not available in Java or Python wrapper libraries.     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li>ArThread.h<li>ArThread.cpp<li>ArThread_LIN.cpp<li>ArThread_WIN.cpp</ul>
<hr size="1"><address style="align: right;"><small>Generated on Thu Jan 7 10:34:44 2010 for Aria by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
