<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Aria: ARIA Overview</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindexHL" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a> | <a class="qindex" href="examples.html">Examples</a></div>
<h1>ARIA Overview </h1>
<p>
<h3 align="center">2.7.2 </h3>MobileRobots <b>Advanced Robotics Interface for Applications (ARIA)</b> Developer's Reference Manual<p>
Copyright 2002, 2003, 2004, 2005 ActivMedia Robotics, LLC. All rights reserved.<br>
 Copyright 2006, 2007, 2008, 2009 MobileRobots Inc. All rights reserved.<br>
 <p>
 
<style type="text/css">
  dt.file {
    font-family: monospace, typewriter, sans;
  }
  dl {
    font-size: small;
    margin-left: 10%;
    margin-right: 10%;
  }
</style>
<h2><a class="anchor" name="toc">
Contents</a></h2>
<ul>
<li>
<a class="el" href="main.html#intro">Introduction</a> <ul>
<li>
<a class="el" href="main.html#javapython">Java and Python</a> </li>
</ul>
</li>
<li>
<a class="el" href="main.html#licensing">License and Sharing</a> </li>
<li>
<a class="el" href="main.html#AriaPackage">The ARIA Package</a> <ul>
<li>
<a class="el" href="main.html#arpack">ARIA/</a> </li>
<li>
<a class="el" href="main.html#arpackother">Other ARIA Files of Note</a> </li>
</ul>
</li>
<li>
<a class="el" href="main.html#codingConventions">Documentation and Coding Convention</a> </li>
<li>
<a class="el" href="main.html#arCliServ">ARIA-Robot Client-Server Relationship</a> </li>
<li>
<a class="el" href="main.html#commClasses">Robot Communication</a> <ul>
<li>
<a class="el" href="main.html#connectRobot">Connecting with a Robot or the Simulator</a> </li>
</ul>
</li>
<li>
<a class="el" href="main.html#HardwareConfiguration">Specifying Details about Robot and Device Connections</a> <ul>
<li>
<a class="el" href="main.html#RobotParameterFiles">Robot Parameter Files</a> </li>
<li>
<a class="el" href="main.html#RuntimeOptions">Program Runtime Options</a> </li>
</ul>
</li>
<li>
<a class="el" href="main.html#robot">ArRobot</a> <ul>
<li>
<a class="el" href="main.html#commands">Client Commands and Server Information Packets</a> </li>
<li>
<a class="el" href="main.html#packetHandlers">Packet Handlers</a> </li>
<li>
<a class="el" href="main.html#CommandPackets">Command Packets</a> </li>
<li>
<a class="el" href="main.html#syncRobot">Robot Synchronization Cycle</a> </li>
<li>
<a class="el" href="main.html#stateReflection">State Reflection</a> </li>
<li>
<a class="el" href="main.html#callback">Robot Callbacks</a> </li>
</ul>
</li>
<li>
<a class="el" href="main.html#ClientCommands">Controlling the robot with Commands and Actions</a> <ul>
<li>
<a class="el" href="main.html#robotDirectCommands">Direct Commands</a> </li>
<li>
<a class="el" href="main.html#robotMotionCommands">Motion Command Functions</a> </li>
<li>
<a class="el" href="main.html#actions">Actions</a> </li>
<li>
<a class="el" href="main.html#actionDesired">Action Desired</a> </li>
<li>
<a class="el" href="main.html#resolvers">The Action Resolver</a> </li>
<li>
<a class="el" href="main.html#predefinedActions">Predefined Actions</a> </li>
<li>
<a class="el" href="main.html#actionInteractions">Mixing Actions</a> </li>
</ul>
</li>
<li>
<a class="el" href="main.html#rangeDevices">Range Devices</a> </li>
<li>
<a class="el" href="main.html#functors">Functors</a> </li>
<li>
<a class="el" href="main.html#userInput">Keyboard and Joystick Input</a> </li>
<li>
<a class="el" href="main.html#threading">Threading</a> <ul>
<li>
<a class="el" href="main.html#syncObject">Thread Syncronizing Objects</a> </li>
<li>
<a class="el" href="main.html#asynctasks">Asynchronous Task Class</a> </li>
</ul>
</li>
<li>
<a class="el" href="main.html#aria">Global Data</a> </li>
</ul>
<h3><a class="anchor" name="tocToolbox">
Additional tools in the ARIA toolbox:</a></h3>
<ul>
<li>
<a class="el" href="main.html#devices">Device and Accessory Interface Classes</a> </li>
<li>
<a class="el" href="main.html#utility">Utility Classes</a> </li>
<li>
<a class="el" href="main.html#arconfig">ArConfig</a> </li>
<li>
<a class="el" href="main.html#sockets">Sockets</a> </li>
<li>
<a class="el" href="main.html#arinfogroup">Shared Info Groups</a> </li>
<li>
<a class="el" href="main.html#maps">Maps</a> </li>
<li>
<a class="el" href="main.html#ArNetworking">ArNetworking</a> </li>
<li>
<a class="el" href="main.html#sound">Sound and Speech</a> </li>
</ul>
<h3><a class="anchor" name="tocDevHelp">
Helpful information about C++ development with ARIA:</a></h3>
<ul>
<li>
<a class="el" href="main.html#emacs">Emacs</a> </li>
<li>
<a class="el" href="main.html#noneverydayC">Non-everyday use of C++</a> <ul>
<li>
<a class="el" href="main.html#stl">Standard Template Library</a> </li>
<li>
<a class="el" href="main.html#defaultArgs">Default Arguments</a> </li>
<li>
<a class="el" href="main.html#constructorChaining">Constructor Chaining</a> </li>
<li>
<a class="el" href="main.html#charsAndStrings">Chars and Strings, Win workaround</a> </li>
<li>
<a class="el" href="main.html#arexport">AREXPORT</a> </li>
<li>
<a class="el" href="main.html#exceptions">Exceptions</a> </li>
</ul>
</li>
</ul>
<h3><a class="anchor" name="tocAdv">
Advanced Usage:</a></h3>
<ul>
<li>
<a class="el" href="main.html#pieceMealUse">Piecemeal Use of ARIA</a> </li>
<li>
<a class="el" href="main.html#hardConnectRobot">Connecting with a Robot or the Simulator the hard way</a> <ul>
<li>
<a class="el" href="main.html#openDevice">Opening the Connection</a> </li>
<li>
<a class="el" href="main.html#devConnect">Robot Client-Server Connection</a> </li>
<li>
<a class="el" href="main.html#connrw">Connection Read, Write, Close and Timestamping</a> </li>
</ul>
</li>
</ul>
<h2><a class="anchor" name="intro">
Introduction</a></h2>
Welcome to ARIA, an object-oriented, robot control applications-programming interface for MobileRobots (and ActivMedia) intelligent mobile robots.<p>
Written in the C++ language, ARIA is client-side software for easy, high-performance access to and management of the robot, as well as to the many accessory robot sensors and effectors. ARIA includes many useful utilities for general robot programming and cross-platform (Linux and Windows) programming as well.<p>
ARIA can be run multi- or single-threaded, using its own wrapper around Linux pthreads or Win32 threads. You can access ARIA at different levels, from simply sending commands to the robot through <a class="el" href="classArRobot.html">ArRobot</a> to development of higher-level intelligent behavior using <a class="el" href="main.html#actions">Actions</a>. (For a description of how to integrate parts of ARIA with your other code, see <a class="el" href="main.html#pieceMealUse">Piecemeal Use of ARIA</a>.)<p>
An auxiliary library called ArNetworking is also included with ARIA. ArNetworking provides an easy to use, extensible framework for communication with remote programs over a network, such as MobileEyes.<p>
This page contains an overview of ARIA. Read this overview to become familiar with the ARIA library and how to get started using it. Click a class or function link to view its detail pages. New users should view this document along with the ARIA examples, README.txt, and your robot's operating manual.<p>
You can download new versions of ARIA from <a href="http://robots.mobilerobots.com/ARIA">http://robots.mobilerobots.com/ARIA</a><h3><a class="anchor" name="whouses">
What is ARIA? How does it relate to other MobileRobots software?</a></h3>
ARIA is a programming library (SDK) for C++ programmers who want to access their MobileRobots or ActivMedia platform and accessories at either a high or low level. ARIA is also for those who have already prepared robot-control software and want to deploy it on one or more MobileRobots or ActivMedia mobile robot platforms. ARIA also provides various tools useful for robot programming in general.<p>
In addition to providing a complete robot and accessory API to developers, ARIA also serves as a foundation for other libraries providing additional capabilities: For creating applications with built-in advanced navigation routines, you can use the additional ARNL or SONARNL libraries. To communicate with the MobileEyes graphical display/control program, or for general communication over the network, you can use ArNetworking. ArNetworking is included with ARIA in the ArNetworking directory. See the ArNetworking Reference Manual for more information.<p>
Other libraries are available as well for specialized purposes, including speech synthesis and recognition, audio stream recording, playback and network transmission, video image capture, color tracking, etc. Browse the MobileRobots support web pages <a href="http://www.activrobots.com">http://www.activrobots.com</a> and <a href="http://robots.mobilerobots.com">http://robots.mobilerobots.com</a> for these libraries and other mobile robotics resources, including the MobileSim simulator which can be used used for programming and debugging before driving an actual robot.<p>
Programmers working with ARIA should be familiar with using typical C++ concepts, including using classes and objects with simple inheritance, pointers, memory management, the STL containers, and the compiling and linking process. (See below for notes about accessing ARIA from Python or Java.) Experience with multiple threads is also helpful.<p>
Read on for information about the key pieces of ARIA and how to get started. See the README.txt file for a brief practical overview of ARIA software development on Linux and Windows. Many example programs are available as well.<h3><a class="anchor" name="javapython">
Java and Python</a></h3>
ARIA, ArNetworking, ARNL and SONARNL now work in Java and Python! Each library has a Java wrapper and a Python wrapper. This means that you can write ARIA programs in Java or Python almost as if ARIA itself was written in these languages. This wrapper is automatically generated by <a href="http://www.swig.org">SWIG</a>, and the Python and Java APIs are almost the same as the C++ library. Exceptions will be noted in this reference manual.<p>
Read javaExamples/README.txt file for directions on how to use the Java wrapper and pythonExamples/README.txt for directions on how to use the Python wrapper, and likewise see ArNetworking/javaExamples and <a href="../ArNetworking/pythonExamples" class="file">ArNetworking/pythonExamples</a> for information about and examples of the ArNetworking Java and Python wrappers.<h2><a class="anchor" name="licensing">
License and Sharing</a></h2>
ARIA is released under the GNU Public License, which means that the entire source code is included and may be copied. However, if you distribute any work which incorporates ARIA, you must also distribute the entire source code to that work, including ARIA with any modifications you may have made, under the same license terms. Read the included <a href="../LICENSE.txt">license text</a> for details. We open-sourced ARIA under the GPL not only for your convenience, but also so that you could share your enhancements to the software with the robotics community (you can share them via the aria-users mailing list). If you wish your enhancements to make it into the ARIA baseline, you will need to assign the copyright on those changes to MobileRobots, contact <a href="mailto:aria-support@mobilerobots.com">aria-support@mobilerobots.com</a> with these changes or with questions about this.<p>
Accordingly, please do share your work, and please sign up for the exclusive <a href="mailto:ARIA-users@mobilerobots.com">ARIA-users@mobilerobots.com</a> newslist so that you can benefit from others' work, too.<p>
For answers to frequently asked questions about what the GPL allows and requires, see <a href="http://www.gnu.org/licenses/gpl-faq.html">http://www.gnu.org/licenses/gpl-faq.html</a> .<p>
On the other hand, ARIA may be also licensed for proprietary, closed-source applications. Contact <a href="mailto:sales@mobilerobots.com">sales@mobilerobots.com</a> for details.<h2><a class="anchor" name="AriaPackage">
The ARIA Package</a></h2>
<h3><a class="anchor" name="arpack">
ARIA/</a></h3>
 
<dl>
  <dt class="file">README.txt</dt>
    <dd>Getting started; essential info. Includes tips on installing
        ARIA, rebuilding it, building example programs, and 
        using platform development tools. 
        Also see the README files in the examples/, advanced/, and tests/
        directories.</dd>

  <dt class="file">LICENSE.txt</dt>
    <dd>GPL license for redistributing ARIA or programs using ARIA</dd>

  <dt class="file">Changes.txt</dt>
    <dd>Summary of changes featured in each version of ARIA</dd>

  <dt class="file">INSTALL.txt</dt>
    <dd>Detailed instructions for installing ARIA on different platforms</dd>

  <dt class="file">docs/</dt>
    <dd>Library reference documentation (this manual).</dd>

  <dt class="file">examples/</dt>
    <dd>ARIA example programs -- a good place to start. Also see the Examples
        section of this reference manual; selected examples are also linked from
        classes and methods used by those examples.
    </dd>


  <dt class="file">include/</dt>
    <dd>Header files for ARIA</dd>

  <dt class="file">src/</dt>
    <dd>ARIA C++ source code files</dd>

  <dt class="file">params/</dt>
    <dd>Robot definition (parameter) files (p3dx.p, for example).
        Mostly used transparently by ARIA, but can be customized 
        if neccesary.
    </dd>

  <dt class="file">lib/</dt>
    <dd>Win32 DLL export library (.lib) files and Linux shared library (.so)
    files</dd>

  <dt class="file">bin/</dt>
    <dd>Win32 binaries and DLLs</dd>
</dl>
<h3><a class="anchor" name="arpackother">
Other ARIA Files of Note</a></h3>
 
<dl>
  <dt class="file">Aria.sln</dt>        <dd>MS Visual C++ workspace for building
  ARIA libraries and examples</dd>
  <dt class="file">Aria.vcproj</dt>     <dd>MSVC++ project file used in Aria.sln
  for the ARIA library.</dd>
  <dt class="file">Makefile</dt>        <dd>Linux makefile for building ARIA and
  examples</dd>
  <dt class="file">Makefile.dep</dt>    <dd>Linux file dependency rules (used internally
  by Makefile)</dd>
  <dt class="file">utils/</dt>
    <dd>Utility programs, used internally by MobileRobots software development,
        plus some file format conversion tools
    </dd>
  <dt class="file">ArNetworking/</dt>   <dd>Networking infrastructure library,
  included with ARIA, but a separate library</dd>
  <dt class="file">tests/</dt>          <dd>Test files, somewhat esoteric but
  useful during ARIA development</dd>
  <dt class="file">advanced/</dt>       <dd>Advanced demos and examples, not
  always for the faint of heart (or ARIA novice)</dd>
  <dt class="file">pythonExamples/</dt> <dd>Information about and examples of
  using ARIA via Python</dd>
  <dt class="file">javaExamples/</dt>   <dd>Information about and examples of
  using ARIA via Java</dd>
  <dt class="file">python/</dt>         <dd>Contains ARIA Python module and
  other files</dd>
  <dt class="file">java/</dt>           <dd>Contains ARIA Java package and other
  files</dd>
</dl>
<h2><a class="anchor" name="codingConventions">
Documentation and Coding Convention</a></h2>
ARIA follows the following coding conventions:<p>
<ol>
<li>
Class names begin with "Ar" and are in mixed case. </li>
<li>
Enums and other constants either begin with a capital letter or are all in caps. </li>
<li>
Avoid preprocessor definitions whenever possible (instead using enumerations or inline methods) </li>
<li>
Member variables in classes are prefixed with 'my'. </li>
<li>
Static variables in classes are prefixed with 'our'. </li>
<li>
Member function names start with a lower case. </li>
<li>
Capitalize each word except the first one in a variable or method name; <code>likeThisForExample</code> </li>
<li>
All classes may be used in a multi-threaded program, either by being inherently threadsafe, or (more typically) by providing an API for protecting it by locking mutexes. See class documentation for notes on access from multiple threads.  </li>
</ol>
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="main.html#emacs">Emacs</a></dd></dl>
<h2><a class="anchor" name="arCliServ">
ARIA-Robot Client-Server Relationship</a></h2>
For those of you who are familiar with SRI International's Saphira software and ActivMedia Robotics' mobile robots and their related technologies, the underlying client-server control architecture for the mobile platform, sensors, and accessories hasn't changed much in ARIA. It's just gotten a lot better and more accessible.<p>
The core mobile robot "server" proceses are implemented in the Pioneer and AmigoBot Operating System firmware (ARCOS, AROS, P2OS, AmigOS, etc.), which runs on the robot's microcontroller. These proceses manage the more critical and time-sensitive low-level tasks of robot control and operation, including maintaining requested motion and heading state and estimating position from odometry, as well as acquiring sensor information (sonar and compass, for example) and driving many accessory components like the PTZ camera, TCM2 compass/inclinometer, and the Pioneer 5-DOF Arm. The robot, its microcontroller, firmware, and integrated devices (such as sonar) together are sometimes referred to as the "robot platform". The robot firmware does not, however, perform any high-level robotic tasks. Rather, it is the job of an intelligent client running on a connected PC to perform these application-level robotic control strategies and tasks, such as obstacle detection and avoidance, sensor fusion, localization, features recognition, mapping, intelligent navigation, PTZ camera control, Arm motion, and much more. ARIA's role is to support these client applications and their communcation with the robot firmware, to any devices that connect to the computer rather than the robot platform, and to remote software via a network.<p>
The heart of ARIA is the <a class="el" href="classArRobot.html">ArRobot</a> class. This class manages the communication cycle with the firmware, receiving and providing access to data about the robot platform's operating state, triggering tasks within that cycle and determining commands to be sent back to the robot (see <a class="el" href="main.html#actions">Actions</a> and <a class="el" href="main.html#syncRobot">Robot Synchronization Cycle</a>). It also serves as a container for references to other ARIA objects (such as range devices) and a toolbox of general functions related to the mobile robot.<p>
Through its <a class="el" href="main.html#actions">Actions</a> infrastructure, ARIA provides a powerful mechanism for combining independent behaviors to achieve coordinated motion control and intelligent guidance. With Actions, you easily implement the motion aspects of applications such as guided teleoperation, visual tracking, autonomous navigation, etc.<p>
Other ARIA classes provide interfaces to access and control accessory sensors and devices, including operation and state reflection for sonar and laser range finders, pan-tilt units, arms, inertial navigation devices, and many others.<h2><a class="anchor" name="commClasses">
Robot Communication</a></h2>
One of the most important functions of ARIA, and one of the first and things that your application program must do, is to establish the connection between an <a class="el" href="classArRobot.html">ArRobot</a> object instance and the robot platform operating system (firmware).<p>
In addition to the mobile robot itself, some accessories, such as the sonar, the Pioneer Gripper, PTZ cameras, Pioneer Arm, compass, and others, are internally connected to the robot microcontroller's AUX or digital I/O lines, and use the robot connection as well (therefore the interface classes for these objects require a reference to an <a class="el" href="classArRobot.html">ArRobot</a> object, which must be connected for the devices to work). Other accessories, such as the SICK laser, video capture cards, etc. are connected directly to the onboard computer.<p>
There are several ways to connect a computer running ARIA to the robot's microcontroller or to a simulator. <a href="figures/Robot_Communication_Options.png">This figure</a> provides a schematic overview of the many ARIA-robot communication options. Consult your robot Operations Manual for more information about computer-robot hardware setup and communications.<h3><a class="anchor" name="connectRobot">
Connecting with a Robot or the Simulator</a></h3>
An <a class="el" href="classArRobotConnector.html">ArRobotConnector</a> object is used to set up and perform the connection to the robot, based on robot parameter files, and run-time configuration via command-line arguments (see <a class="el" href="main.html#HardwareConfiguration">Specifying Details about Robot and Device Connections</a>). Similarly, <a class="el" href="classArLaserConnector.html">ArLaserConnector</a> is used to connect to laser rangefinding devices. (Other connectors are also used for other kinds of accessory devices.) <a class="el" href="classArRobotConnector.html">ArRobotConnector</a> and <a class="el" href="classArLaserConnector.html">ArLaserConnector</a> are used in most of the example programs, including <a class="el" href="simpleConnect_8cpp-example.html">simpleConnect::cpp</a>, <a class="el" href="wander_8cpp-example.html">wander::cpp</a>, and <a class="el" href="demo_8cpp-example.html">demo::cpp</a>. (Some example still use the older <a class="el" href="classArSimpleConnector.html">ArSimpleConnector</a>). <a class="el" href="classArRobotConnector.html">ArRobotConnector</a> will first try to connect to a simulator on a local TCP port, and if no simulator is running, it will then connect to the robot on a local serial port. This makes it easy to develop and debug your program using the simulator, then simply copy it onto the robot's computer and run without modification. <a class="el" href="classArRobotConnector.html">ArRobotConnector</a> also parses some command line arguments if supplied, which can explicitly specify a remote hostname and/or port to connect with via TCP, or to specify an alternate local serial port to use for robot connection, as well as other options. If a program uses <a class="el" href="classArRobotConnector.html">ArRobotConnector</a>, running it with the "-help" command line argument will print a list of options.<p>
Here is an example which uses <a class="el" href="classArRobotConnector.html">ArRobotConnector</a> to connect the <a class="el" href="classArRobot.html">ArRobot</a> and <a class="el" href="classArLaserConnector.html">ArLaserConnector</a> to connect to a laser rangefinder. <div class="fragment"><pre class="fragment"><span class="preprocessor">#include "Aria.h"</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)
{
  <a class="code" href="classAria.html#e23">Aria::init</a>();
  <a class="code" href="classArArgumentParser.html">ArArgumentParser</a> parser(&amp;argc, argv);
  parser.loadDefaultArguments();
  <a class="code" href="classArRobot.html">ArRobot</a> robot;
  <a class="code" href="classArRobotConnector.html">ArRobotConnector</a> robotConnector(&amp;parser, &amp;robot);

  <span class="comment">// Try connecting to the robot.</span>
  <span class="keywordflow">if</span>(!connector.connectRobot(&amp;robot))
  {
    <span class="comment">// Error!</span>
    <a class="code" href="classArLog.html#e4">ArLog::log</a>(<a class="code" href="classArLog.html#w2w8">ArLog::Terse</a>, <span class="stringliteral">"Error, could not connect to robot.\n"</span>);
    robotConnector.logOptions();
    <a class="code" href="classAria.html#e11">Aria::exit</a>(1);
  }

  <span class="comment">// Run the ArRobot processing/task cycle thread.</span>
  robot.<a class="code" href="classArRobot.html#a255">runAsync</a>(<span class="keyword">true</span>);

  <a class="code" href="classArLaserConnector.html">ArLaserConnector</a> laserConnector(&amp;parser, &amp;robot, &amp;robotConnector);

  <span class="comment">// Parse command line arguments (there may be arguments specifying </span>
  <span class="comment">// what lasers to try to connect to)</span>
  <span class="keywordflow">if</span>(!<a class="code" href="classAria.html#e28">Aria::parseArgs</a>())
  {
    <a class="code" href="classAria.html#e27">Aria::logOptions</a>();
    <a class="code" href="classAria.html#e11">Aria::exit</a>(2);
  }

  <span class="comment">// Try connecting to all lasers specified in the robot's parameter file</span>
  <span class="comment">// and in command line arguments</span>
  <span class="keywordflow">if</span>(!laserConnector.connectLasers())
  {
    <a class="code" href="classArLog.html#e4">ArLog::log</a>(<a class="code" href="classArLog.html#w2w8">ArLog::Terse</a>, <span class="stringliteral">"Error, could not connect to lasers.\n"</span>);
    <a class="code" href="classAria.html#e27">Aria::logOptions</a>();
    <a class="code" href="classAria.html#e11">Aria::exit</a>(3);
  }

  <span class="comment">// Now we're connected, and the robot and laser objects are running in </span>
  <span class="comment">// background threads reading and processing data. (You can get access</span>
  <span class="comment">// to the ArLaser objects using ArRobot::findLaser() or</span>
  <span class="comment">// ArRobot::getLaserMap().</span>
  ...
</pre></div><h2><a class="anchor" name="HardwareConfiguration">
Specifying Details about Robot and Device Connections</a></h2>
On any individual robot, there are many possible combinations of hardware accessories, and several options for connecting accessories to the robot and computer. The device interface and connector classes (<a class="el" href="classArRobotConnector.html">ArRobotConnector</a>, <a class="el" href="classArRobotConnector.html">ArRobotConnector</a>, etc.) need information about what devices are connected and how they are connected, especially if they vary from their defaults.<p>
This information is obtained from two sources: the robot's parameter files, and from program runtime arguments via <a class="el" href="classArArgumentParser.html">ArArgumentParser</a> (which reads default program argument values from /etc/Aria.args (on Linux) and the ARIAARGS environment variable (on both Linux and Windows), then reads current program arguments from the command line).<p>
Some examples of hardware configuration options that may need to be specified are what kinds of laser rangefinders are connected, and to which ports, laser connection and data parameters, what kind of GPS is connected and to what port (if a GPS is used). Furthermore, if you are connecting to a robot over a wireless TCP connection from an offboard computer rather than an onboard computer, you must provide a runtime command line argument giving the robot network name (and optionally port number).<h3><a class="anchor" name="RobotParameterFiles">
Robot Parameter Files</a></h3>
Robot parameter files are read by ARIA after a connection to the robot is made and the robot type and individual name are obtained (see <a class="el" href="main.html#connectRobot">Connecting with a Robot or the Simulator</a>). These files provide ARIA with robot-specific conversion factors and physical charactaristics, as well as accessory device connection information.<p>
See <a class="el" href="ParamFiles.html">Robot Parameter Files</a> for more information.<h3><a class="anchor" name="RuntimeOptions">
Program Runtime Options</a></h3>
Various classes in ARIA (notably the Connector classes) use program runtime options (a/k/a command-line arguments).<p>
See <a class="el" href="CommandLineOptions.html">Command Line Option Summary</a> for a summary of all the options that various classes in ARIA accept.<p>
Arguments are provided to other ARIA classes by an <a class="el" href="classArArgumentParser.html">ArArgumentParser</a> object. All ARIA programs should create an <a class="el" href="classArArgumentParser.html">ArArgumentParser</a>, call <a class="el" href="classArArgumentParser.html#a23">ArArgumentParser::loadDefaultArguments()</a> to load any arguments that appear in the <code>/etc/Aria.args</code> file or <code>ARIAARGS</code> environment variable, and provide that object to any class constructors that accept it. Once all such objects are created, you can call <a class="el" href="classAria.html#e27">Aria::logOptions()</a> to print out a summary of all relevant options (e.g. call <a class="el" href="classAria.html#e27">Aria::logOptions()</a>; and <a class="el" href="classAria.html#e11">Aria::exit()</a> if <a class="el" href="classArArgumentParser.html#a5">ArArgumentParser::checkHelpAndWarnUnparsed()</a> returns <code>true</code>, because the user gave the <code>--help</code> option). Finally, call <a class="el" href="classAria.html#e28">Aria::parseArgs()</a> to cause each of them to check the <a class="el" href="classArArgumentParser.html">ArArgumentParser</a> for their respective arguments.<h2><a class="anchor" name="robot">
ArRobot</a></h2>
<a class="el" href="classArRobot.html">ArRobot</a> is the heart of an ARIA program, acting as robot communications gateway, central manager of robot state, tool for synchronizing program-added tasks and callbacks, <a class="el" href="classArAction.html">ArAction</a> objects, etc.<h3><a class="anchor" name="commands">
Client Commands and Server Information Packets</a></h3>
Client-server communications between ARIA and a mobile robot platform or simulator use packet-based protocols. (In this context, the <em>client</em> is the software using ARIA to operate a robot, and the <em>server</em> is the robot platform's firmware.) The details of the client-server protocol can be found in your robot's Operations or Technical Manual.<p>
<a class="el" href="classArRobot.html">ArRobot</a> (using the <a class="el" href="classArDeviceConnection.html">ArDeviceConnection</a>, <a class="el" href="classArRobotPacketReceiver.html">ArRobotPacketReceiver</a>, <a class="el" href="classArRobotPacketSender.html">ArRobotPacketSender</a>, <a class="el" href="classArRobotPacket.html">ArRobotPacket</a>, and <a class="el" href="classArSerialConnection.html">ArSerialConnection</a> classes) handles the details of constructing and sending a command packets to the robot as well as receiving and decoding the packets recieved from the robot server.<h3><a class="anchor" name="packetHandlers">
Packet Handlers</a></h3>
Server Information Packets (SIPs) are packets sent by the robot server containing information updates about the robot and its accessories. The <em>standard SIP</em> is sent by the robot to a connected client automatically every 100 milliseconds (this frequency may be configured in the firmware parameters). It contains the robot's current position and estimates, current translational and rotational speeds, sonar reading updates, battery voltage, analog and digital I/O states, and more. These data are stored and used by ArRobot's State Reflection (see <a class="el" href="main.html#stateReflection">State Reflection</a> below) and are accessible via methods of the <a class="el" href="classArRobot.html">ArRobot</a> class. (Note, within the <a class="el" href="classArRobot.html">ArRobot</a> source code the standard SIP is also called a "motor" packet.)<p>
<em>Extended SIPs</em> use the same packet format as the standard SIP, but with a different packet "type" code. Examples of extended SIPs include I/O port data, data from the gripper, or special robot data like raw encoder data. To receive extended SIPs, the client program must request them. In ARIA, this is normally done by the device interface classes (see <a class="el" href="main.html#devices">Device and Accessory Interface Classes</a>) when they are initialized or when the robot connection is established. You may also attach your own custom packet handlers to <a class="el" href="classArRobot.html">ArRobot</a> using <a class="el" href="classArRobot.html#a7">ArRobot::addPacketHandler()</a>. You can use this to do your own additional processing of extended SIP data, or if creating an alternate implementation of a device interface class.<h3><a class="anchor" name="CommandPackets">
Command Packets</a></h3>
To control the robot platform, a client program sends <em>command packets</em> through the robot connection. This can be done using ArRobot's <a class="el" href="main.html#robotMotionCommands">Motion Command Functions</a>, using <a class="el" href="main.html#actions">Actions</a>, or at the most basic level, <a class="el" href="main.html#robotDirectCommands">Direct Commands</a>. Each of these methods results in command packets sent to the robot. This means that if both Actions and motion commands are used, or if independent program modules are sending motion commands, they may conflict. See <a class="el" href="main.html#ClientCommands">Controlling the robot with Commands and Actions</a> below for more about sending motion commands.<h3><a class="anchor" name="syncRobot">
Robot Synchronization Cycle</a></h3>
The standard SIP is sent on a constant cycle, and reception of this SIP triggers a new iteration of ArRobot's <em>synchronized task processing cycle</em>. This cycle consists of a series of tasks, including SIP packet handling, invocation of sensor interpretation tasks, action handling and resolution, state reflection, and invocation of user tasks, in that order. Since the task cycle is (normally) triggered by the reception of each SIP (unless the robot platform begins to fails to send SIPs or the task cycle is explicitly dissasociated from the robot connection -- see below), each task will be invoked in a predictable order, have the most recent data to act upon, no task will miss an opportunity to use a SIP, and as long as the tasks do not take too much time to execute, each SIP is handled as soon as possible after the robot sends it.<p>
<div align="center">
<img src="ArRobot_Task_Cycle.png" alt="ArRobot_Task_Cycle.png">
<p><strong>Overview of the ArRobot task cycle</strong></p></div>
<p>
To begin the processing cycle, call <a class="el" href="classArRobot.html#a254">ArRobot::run()</a> to enter the cycle synchronously, or <a class="el" href="classArRobot.html#a255">ArRobot::runAsync()</a> to run the cycle in a new background thread. <a class="el" href="classArRobot.html#a327">ArRobot::stopRunning()</a> stops the processing cycle.<p>
<a class="el" href="classArRobot.html">ArRobot</a> provides methods to add your own sensor-interpretation and generic user task callbacks. To add a task callback, create an <a class="el" href="classArFunctor.html">ArFunctor</a> function object (see <a class="el" href="main.html#functors">Functors</a>) and then add it using <a class="el" href="classArRobot.html#a10">ArRobot::addSensorInterpTask()</a> or <a class="el" href="classArRobot.html#a12">ArRobot::addUserTask()</a>. These tasks can be removed using <a class="el" href="classArRobot.html#a245">ArRobot::remSensorInterpTask()</a> or <a class="el" href="classArRobot.html#a248">ArRobot::remUserTask()</a>.<p>
<a class="el" href="classArRobot.html">ArRobot</a> locks it's mutex (see <a class="el" href="classArRobot.html#a217">ArRobot::lock()</a> and <a class="el" href="classArRobot.html#a330">ArRobot::unlock()</a>) during each iteration of the task cycle, so your task callbacks must not lock this mutex--a deadlock will occur. (However, locks must still be used for safe access to any other thread or ArAsyncTask, such as ArSick or other range devices, or ARNL's planning or localization tasks.) This mutex lock protects <a class="el" href="classArRobot.html">ArRobot</a> data from modification by other threads (if they correctly use the lock during access), and interruption of the series of tasks. So if you access <a class="el" href="classArRobot.html">ArRobot</a> from any other thread (including the main thread, if you used <a class="el" href="classArRobot.html#a255">ArRobot::runAsync()</a> to run the task cycle), you must use <a class="el" href="classArRobot.html#a217">ArRobot::lock()</a> and <a class="el" href="classArRobot.html#a330">ArRobot::unlock()</a> to lock and unlock the robot before and after any method call or use of any data in <a class="el" href="classArRobot.html">ArRobot</a>.<p>
It is also possible to run the processing cycle without a connection to a robot, if desired. This alternative cycle is not triggered by receiving a packet, instead it has its own steady, "chained" cycle time (default is 100 milliseconds which you may examine and reset with <a class="el" href="classArRobot.html#a79">ArRobot::getCycleTime()</a> and <a class="el" href="classArRobot.html#a271">ArRobot::setCycleTime()</a>). You may also explicitly disassociate ArRobot's processing cycle from incoming SIP processing at any time by calling <a class="el" href="classArRobot.html#a270">ArRobot::setCycleChained()</a> ("Chained" means that it is the end of a previous cycle that triggers the next after suitable delay to meet the desired cycle frequency). However, in doing so, you may degrade performance, as the robot's cycle will only be run every <a class="el" href="classArRobot.html#a79">ArRobot::getCycleTime()</a> milliseconds, and each time only the most recently read (oldest) SIP is used (even if the robot has sent more than one since the last cycle).<p>
ArRobot's synchronization task list is ipmlemented as a tree, with five major branches. Though it is uncommon to do so, a client program may modify this tree or disable branch tasks of the tree. If a particular task is disabled, none of its children will be called. The root of the task tree can be obtained by calling <a class="el" href="classArRobot.html#a171">ArRobot::getSyncTaskRoot()</a>, which returns an <a class="el" href="classArSyncTask.html">ArSyncTask</a> object.<h3><a class="anchor" name="stateReflection">
State Reflection</a></h3>
State reflection in the <a class="el" href="classArRobot.html">ArRobot</a> class is the way ARIA maintains a snapshot of the robot's operating conditions and values, such as estimated pose, current velocity, battery voltage, etc. as extracted from the latest standard SIP. <a class="el" href="classArRobot.html">ArRobot</a> methods for examining these values include <a class="el" href="classArRobot.html#a134">ArRobot::getPose()</a>, <a class="el" href="classArRobot.html#a183">ArRobot::getX()</a>, <a class="el" href="classArRobot.html#a184">ArRobot::getY()</a>, <a class="el" href="classArRobot.html#a173">ArRobot::getTh()</a>, <a class="el" href="classArRobot.html#a182">ArRobot::getVel()</a>, <a class="el" href="classArRobot.html#a158">ArRobot::getRotVel()</a>, <a class="el" href="classArRobot.html#a68">ArRobot::getBatteryVoltage()</a>, <a class="el" href="classArRobot.html#a205">ArRobot::isLeftMotorStalled()</a>, <a class="el" href="classArRobot.html#a209">ArRobot::isRightMotorStalled()</a>, <a class="el" href="classArRobot.html#a74">ArRobot::getCompass()</a>, <a class="el" href="classArRobot.html#a67">ArRobot::getAnalogPortSelected()</a>, <a class="el" href="classArRobot.html#a66">ArRobot::getAnalog()</a>, <a class="el" href="classArRobot.html#a83">ArRobot::getDigIn()</a>, <a class="el" href="classArRobot.html#a84">ArRobot::getDigOut()</a>.<p>
The standard SIP also contains sonar reading updates, which are reflected in <a class="el" href="classArRobot.html">ArRobot</a> and examined with the methods: <a class="el" href="classArRobot.html#a125">ArRobot::getNumSonar()</a>, <a class="el" href="classArRobot.html#a162">ArRobot::getSonarRange()</a>, <a class="el" href="classArRobot.html#a212">ArRobot::isSonarNew()</a>, <a class="el" href="classArRobot.html#a163">ArRobot::getSonarReading()</a>, <a class="el" href="classArRobot.html#a73">ArRobot::getClosestSonarRange()</a>, <a class="el" href="classArRobot.html#a72">ArRobot::getClosestSonarNumber()</a>. The sonar interface class, <a class="el" href="classArSonarDevice.html">ArSonarDevice</a>, also receives this information (see <a class="el" href="main.html#rangeDevices">Range Devices</a>).<p>
<a class="el" href="classArRobot.html">ArRobot</a> also uses the state reflection task to send previously requested motion commands (see <a class="el" href="main.html#robotMotionCommands">Motion Command Functions</a>) to the robot, so the motion commands sent to the robot reflects those desired values set in ArRobot's state reflection by actions or motion command methods, and also so that the watchdog on the robot does not time out and disable the robot (if no motion command is set, <a class="el" href="classArCommands.html#w6w53">ArCommands::PULSE</a> is sent each cycle). You can further tune state reflection's motion command sending rate if neccesary with <a class="el" href="classArRobot.html#a314">ArRobot::setStateReflectionRefreshTime()</a>.) If desired, you may turn the motion-control state reflector off in the ArRobot::ArRobot() constructor (set the <em>doStateReflection</em> parameter to false). This will cause motion command functions to only be send the command once directly to the robot whenever they are called, rather than storing the command to send each cycle.<h3><a class="anchor" name="callback">
Robot Callbacks</a></h3>
There are a number of useful callbacks invoked by <a class="el" href="classArRobot.html">ArRobot</a> on connection events. You can add and remove them with the functions <a class="el" href="classArRobot.html#a2">ArRobot::addConnectCB()</a>, <a class="el" href="classArRobot.html#a234">ArRobot::remConnectCB()</a>, <a class="el" href="classArRobot.html#a5">ArRobot::addFailedConnectCB()</a>, <a class="el" href="classArRobot.html#a237">ArRobot::remFailedConnectCB()</a>, <a class="el" href="classArRobot.html#a3">ArRobot::addDisconnectNormallyCB()</a>, <a class="el" href="classArRobot.html#a235">ArRobot::remDisconnectNormallyCB()</a>, <a class="el" href="classArRobot.html#a4">ArRobot::addDisconnectOnErrorCB()</a>, <a class="el" href="classArRobot.html#a236">ArRobot::remDisconnectOnErrorCB()</a>, <a class="el" href="classArRobot.html#a9">ArRobot::addRunExitCB()</a>, <a class="el" href="classArRobot.html#a243">ArRobot::remRunExitCB()</a>. Read their individual documentation pages for details.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="robotConnectionCallbacks_8cpp-example.html">robotConnectionCallbacks::cpp</a></dd></dl>
<h2><a class="anchor" name="ClientCommands">
Controlling the robot with Commands and Actions</a></h2>
Your ARIA client can drive the robot and run its various accessories through ArRobot's Direct Commands, Motion Commands, or through Actions.<p>
<dl compact><dt><b>Note:</b></dt><dd>The robot's movement speed will be limited by several parameters. First, the maximum velocities, accelerations and decelerations given in ARIA's robot parameter file (.p file) (TransVelMax, RotVelMax, TransAccel, TransDecel, RotAccel, RotDecel, and for the Seekur only, LatVelMax, LatAccel and LatDecel) are used to limit motion commands sent by ARIA, if the value is nonzero. Next, the max velocities given in the robot firmware (ARCOS) configuration are used to limit motion commands recieved by the robot. All of these maximum values can be changed at runtime with the <a class="el" href="classArRobot.html#a317">ArRobot::setTransVelMax()</a>, <a class="el" href="classArRobot.html#a309">ArRobot::setRotVelMax()</a>, and for the Seekur only, <a class="el" href="classArRobot.html#a287">ArRobot::setLatVelMax()</a> calls. These calls change the parameters in the robot firmware, as well as in ARIA. That is, they override any maximum values given in the robot parameter file (.p file). Finally, the "Top" parameters in the firmware (ARCOS) configuration limit speeds; these cannot be changed at runtime, only using the configuration program. Most robot parameter files use 0 values as maximums, disabling ARIA's initial limiting check; however, to make the Seekur easier to initially teleoperate at safe speeds, the velocity limits in seekur.p are set. Change these limits to 0 to remove those speed limits, and use the platform's defaults, or use ArRobot's methods to change them at program runtime.</dd></dl>
<h3><a class="anchor" name="robotDirectCommands">
Direct Commands</a></h3>
At the lowest level of robot access, you may send any command packet directly to the robot or simulator platform through <a class="el" href="classArRobot.html">ArRobot</a>. Direct commands consist of a 1-byte command number followed by none or more arguments, as defined by the robot's operating system (ARCOS, AROS, P2OS, AmigOS, etc.). For example, the command number 4, ENABLE, enables the robot's motors if accompanied by the argument 1, and disables the motors with the argument 0. Use <a class="el" href="classArRobot.html#a28">ArRobot::com()</a> for commands that have no argument, such as PULSE; <a class="el" href="classArRobot.html#a31">ArRobot::comInt()</a> for a 2-byte integer argument, signed or unsigned, such as the motors ENABLE command; <a class="el" href="classArRobot.html#a29">ArRobot::com2Bytes()</a> for commands that accept two individual bytes as the argument, such as the VEL2 command; and <a class="el" href="classArRobot.html#a32">ArRobot::comStr()</a> or <a class="el" href="classArRobot.html#a33">ArRobot::comStrN()</a> for a null-terminated or fixed-length string argument, respectively, such as the sonar POLLING sequencing command.<p>
The <a class="el" href="classArCommands.html">ArCommands</a> class contains an enum with all the direct commands; <a class="el" href="classArCommands.html#w6w11">ArCommands::ENABLE</a>, for example. Not all Direct Commands are supported by every MobileRobots robot, but unrecognized (or malformed) commands are simply ignored.<p>
Please consult your robot's technical manual for details, such as the Chapter 6 in the Pioneer 3 Operations Manual, for client command numbers and syntax.<p>
For most commands, a method exists in <a class="el" href="classArRobot.html">ArRobot</a> that either sends the command immediately, or stores it for the state reflection task to send. However, the direct command methods allow you to send any unusual or special commands directly to the robot platform or simulator, without any intervening processing.<h3><a class="anchor" name="robotMotionCommands">
Motion Command Functions</a></h3>
At a level just above ArRobot's Direct Commands are the Motion Command Functions. These are explicit simple movement commands sent by ArRobot's state reflection task. For example, <a class="el" href="classArRobot.html#a320">ArRobot::setVel()</a> to set the translational velocity, <a class="el" href="classArRobot.html#a308">ArRobot::setRotVel</a> to set rotational velocity, <a class="el" href="classArRobot.html#a321">ArRobot::setVel2()</a> to or set each wheel speeds separately, <a class="el" href="classArRobot.html#a282">ArRobot::setHeading()</a> to set a global heading angle to turn to, <a class="el" href="classArRobot.html#a223">ArRobot::move()</a> to drive a given distance, or <a class="el" href="classArRobot.html#a324">ArRobot::stop()</a> to stop all motion. <a class="el" href="classArRobot.html">ArRobot</a> also provides methods for setting speed limits beyond the limits set in the firmware configuration. These motion functions work at part of with <a class="el" href="main.html#stateReflection">State Reflection</a>, and <a class="el" href="classArRobot.html">ArRobot</a> may resend commands each cycle to try to achieve the desired state.<p>
Be aware that a Direct or a Motion Command may conflict with controls from Actions or other upper-level processes and lead to unexpected consequences. Use <a class="el" href="classArRobot.html#a27">ArRobot::clearDirectMotion()</a> to cancel the overriding effect of a previously set Motion Command so that your Action is able to regain control the robot. Or limit the time a Motion Command prevents other motion actions with <a class="el" href="classArRobot.html#a276">ArRobot::setDirectMotionPrecedenceTime()</a>. Otherwise, the Motion Command will prevent actions forever. Use <a class="el" href="classArRobot.html#a85">ArRobot::getDirectMotionPrecedenceTime()</a> to see how long a Motion Command takes precedence once set.<h3><a class="anchor" name="actions">
Actions</a></h3>
While simple sequences motion commands can be easy to use, trying to achieve more sophisticated motion using only motion commands can quickly become difficult. To make it possible to define complex behaviors out of independent, reusable components, ARIA provides the higher-level <em>Actions</em> system. Actions are individual objects that independently provide motion requests which are evaluated and then combined each cycle to produce a final set of movement commands. This allows you to build complex behavior from simple building blocks for dynamic and continuous motion control.<p>
Actions are defined by creating a subclass of the <a class="el" href="classArAction.html">ArAction</a> the base class which overloads the <a class="el" href="classArAction.html#a3">ArAction::fire()</a> method. See the <code><a class="el" href="actionExample_8cpp-example.html">actionExample::cpp</a></code> example program. ARIA also includes some pre-made action classes: look for them as subclasses of <a class="el" href="classArAction.html">ArAction</a> in its class documentation or in in the ARIA source code (the files begin with <a class="el" href="classArAction.html">ArAction</a>...).<p>
Actions are attached to an <a class="el" href="classArRobot.html">ArRobot</a> object with <a class="el" href="classArRobot.html#a1">ArRobot::addAction()</a>, along with a priority which determines its position in the action list. <a class="el" href="classArAction.html#a14">ArAction::setRobot()</a> is called on an action object when it is added to a robot. You can override this in your action subclass. (For example, this would be useful to add a connection callback, if there were some calculations you wished to do upon connection to the robot.)<p>
Actions are evaluated by ArRobot's <em>action resolver</em> in descending order of priority (highest priority first, lowest priority last) in each task cycle just prior to <a class="el" href="main.html#stateReflection">State Reflection</a>. The action resolver invokes each action's fire() method, combining their desired motion commands (the <a class="el" href="classArActionDesired.html">ArActionDesired</a> objects they return) to a single <a class="el" href="classArActionDesired.html">ArActionDesired</a> object, which is then used in state reflection to send motion commands to the robot.<p>
<dl compact><dt><b>Note:</b></dt><dd>Sending simple motion commands (e.g. by using <a class="el" href="classArRobot.html#a320">ArRobot::setVel()</a>) while actions are also active can result in conflicts between your simple motion commands and the action resolver's commands. See the discussion of <a class="el" href="main.html#robotMotionCommands">Motion Command Functions</a> above.</dd></dl>
As the resolver is invoking each action, by it passes the current desired motion combined from the previously invoked, higher priority actions, as the currentDesired argument to fire(). This can be useful information if needed. (For example, a stall-recovery action could be programmed not to exert its motion effects if it has been pre-empted by a stop action, so this stall-recovery action would check currentDesired to see if either the "strength" is "used up" or if there is a maximum velocity, and if so, reset its own state.) However, there is no need for an action to pay attention to the currentDesired if not necessary.<h3><a class="anchor" name="actionDesired">
Action Desired</a></h3>
<a class="el" href="classArActionDesired.html">ArActionDesired</a> objects are used to pass desired action channel values and strengths out of an <a class="el" href="classArAction.html#a3">ArAction::fire()</a> method back to the resolver. An <a class="el" href="classArActionDesired.html">ArActionDesired</a> object should always be reset (<a class="el" href="classArActionDesired.html#a50">ArActionDesired::reset()</a>) before it is reused.<p>
There are six action channels: velocity (<a class="el" href="classArActionDesired.html#a67">ArActionDesired::setVel</a>), heading (<a class="el" href="classArActionDesired.html#a51">ArActionDesired::setDeltaHeading</a> or <a class="el" href="classArActionDesired.html#a52">ArActionDesired::setHeading</a> for absolute heading), maximum forward translational velocity (<a class="el" href="classArActionDesired.html#a60">ArActionDesired::setMaxVel</a>), maximum reverse translational velocity (<a class="el" href="classArActionDesired.html#a57">ArActionDesired::setMaxNegVel</a>), and maximum rotational velocity (<a class="el" href="classArActionDesired.html#a59">ArActionDesired::setMaxRotVel</a>).<p>
An action gives each channel a strength between 0.0, the lowest, and 1.0, the highest. Strengths are used by the resolver to compute the relative effect of the associated channel when combining multiple actions' desired movements.<p>
The maximum velocity, maximum negative velocity, and maximum rotational velocity channels simply impose speed limits and thereby indirectly control the robot.<p>
For more advanced usage, <a class="el" href="classArActionDesired.html">ArActionDesired</a> objects can be merged (<a class="el" href="classArActionDesired.html#a49">ArActionDesired::merge</a>) and averaged (<a class="el" href="classArActionDesired.html#a68">ArActionDesired::startAverage</a>, <a class="el" href="classArActionDesired.html#a1">ArActionDesired::addAverage</a>, <a class="el" href="classArActionDesired.html#a3">ArActionDesired::endAverage</a>).<h3><a class="anchor" name="resolvers">
The Action Resolver</a></h3>
<a class="el" href="classArResolver.html">ArResolver</a> is the base action resolver class. <a class="el" href="classArPriorityResolver.html">ArPriorityResolver</a> is the default resolver used by <a class="el" href="classArRobot.html">ArRobot</a>.<p>
The resolver used by <a class="el" href="classArRobot.html">ArRobot</a> may be changed by calling <a class="el" href="classArRobot.html#a304">ArRobot::setResolver</a>, if you wish to create an alternative <a class="el" href="classArResolver.html">ArResolver</a> implementation. There may only be one resolver per <a class="el" href="classArRobot.html">ArRobot</a> object. (Though a resolver could contain within it multiple resolvers of its own.) Note that although a robot has one particular resolver bound to it, a resolver instance is not tied to any robot.<p>
The priority resolver works by iterating through the action list in descending priority (from greatest priority value to lowest), setting each robot movement channel (trans. velocity, heading, max. velocity, etc.) based on the contributing actions' desired values (as returned from their fire() methods) in proportion to their respective strengths as well as the actions' priorities, updating each movement channel until its strength becomes 1.0 or the action list is exhausted. Once a channel's accumulated strength reaches 1.0, no more changes may be made to that channel (this is how higher priority actions can prevent lower priority actions from changing a channel). Same-priority actions are averaged together if they both provide outputs for the same channel.<p>
As an example, the following table illustrates at each step an action's desired value and strength for the <b>velocity</b> channel, and the resulting change to the resolver's final velocity channel value and strength decision, for four fictional actions (A, B, C and D):<p>
<table border="1" cellspacing="0" style="td, th { font-size: 90%; }" summary="Example result for velocity channel from four enabled actions" cellpadding="3">
<tr>
<th>step # </th><th>action </th><th>priority </th><th>value of action's desired-velocity channel </th><th>strength of action's desired-velocity channel </th><th>current final velocity value </th><th>current final velocity strength </th></tr>
<tr>
<td>1 </td><td>A </td><td>4 </td><td>-400 </td><td>0.25 </td><td>-400 </td><td>0.25 </td></tr>
<tr>
<td>2 </td><td>B </td><td>3 </td><td>-100 </td><td>1.0 </td><td colspan="2" rowspan="2" valign="middle" align="center">Combined for use in step 4 </td></tr>
<tr>
<td>3 </td><td>C </td><td>3 </td><td>200 </td><td>0.50  </td></tr>
<tr>
<td>4 </td><td>B&amp;C </td><td>3 </td><td>0 </td><td>0.75 </td><td>-100 </td><td>1.0 </td></tr>
<tr>
<td>5 </td><td>D </td><td>1 </td><td>500 </td><td>0.50 </td><td>no change </td><td>no change </td></tr>
<tr>
<th colspan="3" align="left">final result</th><td></td><td></td><td>-100</td><td>1.0 </td></tr>
</table>
<p>
Notice in the example that the same-priority actions B and C are averaged before being combined with the previously computed values from step 1. The resulting combination is: ( (B desired velocity: -100) X (B velocity strength: 1.0) + (C desired velocity: 200) X (C velocity strength: 0.5) ) / 2 =&gt; (-100 + 100) / 2 =&gt; 0 Therefore actions B and C end up cancelling each other out. Combining this result with the "currentDesired" values computed in step 1 gives (step 1 desired velocity: -400) X (step 1 velocity strength: 0.25) + (step 4 desired velocity: 0) X (step 4 velocity strength: 0.75) =&gt; -100.<p>
In this example, it turns out that at step 5, action D has no effect since the strength for this channel has reached 1.0 at step 4, before that action was considered by the resolver.<p>
The same method is used for all of the other channels.<h3><a class="anchor" name="predefinedActions">
Predefined Actions</a></h3>
ARIA has several predefined action classes. <em>Movement</em> action classes have an "ArAction" prefix and set either or both the translational velocity (setVel) and heading (setDeltaHeading and setHeading) channels to effect motion. <em>Limiting</em> action classes are prefixed with "ArActionLimiter" and set one or more of the maximum translational and rotational velocity channels, to slow down or prevent motion, usually based on conditions such as nearby sensor readings.<p>
See the <a class="el" href="classArAction.html">ArAction</a> base class's list of subclasses.<h3><a class="anchor" name="actionInteractions">
Mixing Actions</a></h3>
Actions are most useful when mixed. The <a class="el" href="teleopActionsExample_8cpp-example.html">teleopActionsExample::cpp</a> example program is a good example of mixing limiting and movement actions. It creates several limiting actions, including Limiter, LimiterFar, and so on, and two movement actions, joydriveAct and keydriveAct. The limiting actions have higher priority than the movement ones, thereby preventing driving if it might be potentially unsafe due to obstacles detected by sensors.<p>
This example also illustrates fundamental, yet very powerful features of ARIA actions and how they contribute to the overall behavior of the mobile robot. Because they are individuals, contributing discretely to the movements of the robot, actions are easily reusable. For example, a limiting action that prevents the robot from crashing into a wall when translating forward, can be used, as is, in another ARIA program and have the identical effect, except that instead of driving the robot with a joystick, the new program's lower-priority movement action might use color-tracking to have the robot follow a rolling ball. The ball-following action doesn't need to know anything about the finer arts of safe navigation--the higher-priority limiting actions take care of that.<p>
Another ARIA example program, <a class="el" href="wander_8cpp-example.html">wander::cpp</a> demonstrates how different movement actions can be used and how they interact. The stall-recover action in wander (<a class="el" href="classArActionStallRecover.html">ArActionStallRecover</a>) influences the robot's movements only when the motors are stalled, disabling the lower priority actions by using up all translational and rotational strength until the robot has extracted from the stall. You should also examine ArActionStallRecover.cpp in the src/ directory to see how the action changes its motion control influences based on the stall state. Also note how <a class="el" href="classArActionAvoidFront.html">ArActionAvoidFront</a> and <a class="el" href="classArActionConstantVelocity.html">ArActionConstantVelocity</a> interact.<h3><a class="anchor" name="actionGroups">
Action Groups</a></h3>
Action groups allow you to easily enable (activate) or disable (de-activate) a set of actions at once. You must first create an <a class="el" href="classArActionGroup.html">ArActionGroup</a> attached to an <a class="el" href="classArRobot.html">ArRobot</a>. Then, when you add an <a class="el" href="classArAction.html">ArAction</a> to the <a class="el" href="classArActionGroup.html">ArActionGroup</a>, it is automatically added to the <a class="el" href="classArRobot.html">ArRobot</a>, as well as to the group.<p>
Several predefined action groups are provided by ARIA.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="actionGroupExample_8cpp-example.html">actionGroupExample::cpp</a></dd></dl>
<h2><a class="anchor" name="rangeDevices">
Range Devices</a></h2>
Range devices (<a class="el" href="classArRangeDevice.html">ArRangeDevice</a>) are abstractions of sensors which detect the presence of obstacles in the space around the robot, providing a series of spatial readings over time. ARIA's range device classes transform all readings into specific points in the same two-dimensional global coordinate system. (This is the same coordinate system as ArRobot's pose).<p>
Currently, the main <a class="el" href="classArRangeDevice.html">ArRangeDevice</a> implementations included with ARIA are: sonar (<a class="el" href="classArSonarDevice.html">ArSonarDevice</a>), laser (<a class="el" href="classArLaser.html">ArLaser</a> and subclasses), the robot bumpers (<a class="el" href="classArBumpers.html">ArBumpers</a>), and the "table-sensing" infrared sensors of a PeopleBot (<a class="el" href="classArIRs.html">ArIRs</a>). Camera and 3D range devices (MobileRanger devices) are supported by separate software. In addition, <a class="el" href="classArForbiddenRangeDevice.html">ArForbiddenRangeDevice</a> is a "virtual" range device that creates range readings that border "forbidden area" and "forbidden line" regions in an <a class="el" href="classArMap.html">ArMap</a>, and ArRangeDeviceFilter processes the output another <a class="el" href="classArRangeDevice.html">ArRangeDevice</a> object in a few ways and provides the processed data through the <a class="el" href="classArRangeDevice.html">ArRangeDevice</a> interface. Its parameters can be modified on line through <a class="el" href="classArConfig.html">ArConfig</a>.<p>
<a class="el" href="classArRangeDevice.html">ArRangeDevice</a> holds two kinds of <a class="el" href="classArRangeBuffer.html">ArRangeBuffer</a> objects to store readings: <em>current</em> and <em>cumulative</em>, though not all <a class="el" href="classArRangeDevice.html">ArRangeDevice</a> implementations supply data to the cumulative buffer. The current buffer contains the most recent set of readings; the cumulative buffer contains readings gathered over a longer period time, limited by the buffer's size (see <a class="el" href="classArRangeBuffer.html#a24">ArRangeBuffer::setSize()</a>).<p>
Some range devices also provide "raw" readings, which are the original values given by the device itself. Some range devices are also considered "Planar", which means that the readings may undergo some processing to remove duplicates etc., and which include raw readings. This includes the lasers.<p>
Range devices are connected to a specific <a class="el" href="classArRobot.html">ArRobot</a> instance, to obtain position and other information from the robot when readings are received and stored, and also to provide a way to find all range devices attached to the robot. Some range devices use the robot connection to communicate to their device (e.g. <a class="el" href="classArSonarDevice.html">ArSonarDevice</a>, <a class="el" href="classArBumpers.html">ArBumpers</a>, <a class="el" href="classArIRs.html">ArIRs</a>). Attach an <a class="el" href="classArRangeDevice.html">ArRangeDevice</a> to your <a class="el" href="classArRobot.html">ArRobot</a> object with <a class="el" href="classArRobot.html#a8">ArRobot::addRangeDevice()</a> and remove it with <a class="el" href="classArRobot.html#a242">ArRobot::remRangeDevice()</a>. The list of all attached devices can be queried using <a class="el" href="classArRobot.html#a49">ArRobot::findRangeDevice()</a> and <a class="el" href="classArRobot.html#a190">ArRobot::hasRangeDevice()</a>. The list can be obtained by calling <a class="el" href="classArRobot.html#a138">ArRobot::getRangeDeviceList()</a>.<p>
(Note that although sonar are integrated with the robot microcontroller, and the microcontroller always sends sonar data to the robot (if the robot has sonar), you still must attach an <a class="el" href="classArSonarDevice.html">ArSonarDevice</a> object to the robot to use it.)<p>
<a class="el" href="classArRangeDevice.html">ArRangeDevice</a> also includes some methods to help find the closest reading to the robot within a selected box, or a polar sector: <a class="el" href="classArRangeDevice.html#a10">ArRangeDevice::currentReadingPolar()</a>, <a class="el" href="classArRangeDevice.html#a9">ArRangeDevice::currentReadingBox()</a>, <a class="el" href="classArRangeDevice.html#a8">ArRangeDevice::cumulativeReadingPolar()</a>, <a class="el" href="classArRangeDevice.html#a7">ArRangeDevice::cumulativeReadingBox()</a>.<p>
<a class="el" href="classArRobot.html">ArRobot</a> also includes similar methods to do common operations on all attached range devices, including <a class="el" href="classArRobot.html#a26">ArRobot::checkRangeDevicesCurrentPolar()</a>, <a class="el" href="classArRobot.html#a25">ArRobot::checkRangeDevicesCurrentBox()</a>, ArRobot::checkRangesDevicesCumulativePolar(), and <a class="el" href="classArRobot.html#a23">ArRobot::checkRangeDevicesCumulativeBox()</a> to find the closest range reading to the robot within some region.<p>
Each range device has a mutex (Use <a class="el" href="classArRangeDevice.html#a37">ArRangeDevice::lockDevice()</a> and <a class="el" href="classArRangeDevice.html#a51">ArRangeDevice::unlockDevice()</a> to lock and unlock it) so that it can be accessed safely by multiple threads. For example, ArSick uses a thread to read data from a laser, but the checkRangeDevice functions in <a class="el" href="classArRobot.html">ArRobot</a> lockDevice() so they can read the data without conflicting with ArSick's data-reading thread, then use unlockDevice() when done. See <a class="el" href="main.html#threading">Threading</a> for more about threading in ARIA.<h2><a class="anchor" name="functors">
Functors</a></h2>
Functors are used throughout ARIA. Functor is short for function pointer. A Functor lets you call a function without knowing the declaration of the function. Instead, the compiler and linker figure out how to properly call the function.<p>
Function pointers are fully supported by the C language. C++ treats function pointers like C, but to call class methods, an instance object is required, as well as type information about the class. Therefore, ARIA contains a set of template classes to contain this information.<p>
ARIA makes heavy use of ArFunctors as "callback" functions. To instantiate a functor, you first need to identify how many parameters the function needs and if it returns a value. Many times a pointer to the abstract <a class="el" href="classArFunctor.html">ArFunctor</a> base class is used, which can be invoked with no parameters and no return value. Subclasses are used for functions with different numbers of parameters and return values. <a class="el" href="classArFunctor1.html">ArFunctor1</a>, <a class="el" href="classArFunctor2.html">ArFunctor2</a>, <a class="el" href="classArRetFunctor.html">ArRetFunctor</a>, <a class="el" href="classArRetFunctor1.html">ArRetFunctor1</a>, and <a class="el" href="classArRetFunctor2.html">ArRetFunctor2</a> for example. When invoked, the parameters may be supplied which are passed to the target function or method, and a return value may also be given. The types for the arguments and/or return value are given as template arguments.<p>
When creating a functor object, however, you must also provide the type and instance of an object to invoke the method of; or explicitly state that the function is a class-less global function. Do this by using one of the concrete base classes of <a class="el" href="classArFunctor.html">ArFunctor</a> instead of the abstract classes: <a class="el" href="classArFunctorC.html">ArFunctorC</a>, <a class="el" href="classArFunctor1C.html">ArFunctor1C</a>, <a class="el" href="classArFunctor2C.html">ArFunctor2C</a>, <a class="el" href="classArRetFunctorC.html">ArRetFunctorC</a>, <a class="el" href="classArRetFunctor1C.html">ArRetFunctor1C</a>, <a class="el" href="classArRetFunctor2C.html">ArRetFunctor2C</a>, <a class="el" href="classArGlobalFunctor.html">ArGlobalFunctor</a>, <a class="el" href="classArGlobalFunctor1.html">ArGlobalFunctor1</a>, etc.<p>
Example:<p>
<div class="fragment"><pre class="fragment">    <span class="keyword">class </span>ExampleClass {
    <span class="keyword">public</span>:
        <span class="keywordtype">void</span> aFunction(<span class="keywordtype">int</span> n);
    };
  
    ...
      
    ExampleClass obj;
    <a class="code" href="classArFunctor1C.html">ArFunctor1C&lt;ExampleClass, int&gt;</a> functor(obj, &amp;ExampleClass::aFunction);

    ...

    functor.invoke(42);
</pre></div><p>
<code>ExampleClass</code> is a class which contains a function called <code>aFunction()</code>. Once the functor is created in this fashion, it can now be passed off to an ARIA function that wants a callback functor. And the method <code>ExampleClass::aFunction()</code> will be called on the object <code>obj</code> when the functor is invoked.<p>
To invoke a functor, simply call the invoke function on the functor. If it takes parameters, call invoke with those parameters. If the functor has a return value, call invokeR. The return value of the function will be passed back through the invokeR function.<h2><a class="anchor" name="userInput">
Keyboard and Joystick Input</a></h2>
ARIA provides several classes getting live joystick and keyboard input, and action classes (see <a class="el" href="main.html#actions">Actions</a>) that use that input to drive the robot.<p>
<a class="el" href="classArJoyHandler.html">ArJoyHandler</a> is a cross-platform interface to joystick data. It's key functions are ArJoyHandler::getButtons, <a class="el" href="classArJoyHandler.html#a2">ArJoyHandler::getAdjusted</a>, <a class="el" href="classArJoyHandler.html#a15">ArJoyHandler::setSpeeds</a>, and <a class="el" href="classArJoyHandler.html#a5">ArJoyHandler::getDoubles</a>.<p>
<a class="el" href="classArKeyHandler.html">ArKeyHandler</a> is a cross-platform interface for recieving single keystroke events (instead of buffered lines of text). It's key function is <a class="el" href="classArKeyHandler.html#a0">ArKeyHandler::addKeyHandler</a>, which binds a specific key to a given functor. It contains an enum <a class="el" href="classArKeyHandler.html#w22">ArKeyHandler::KEY</a> that contains values for special keys. You can also attach a key handler to a robot with <a class="el" href="classArRobot.html#a20">ArRobot::attachKeyHandler()</a>, which adds some default key handlers, including a handler for Escape that disconnects and exits the program (especially useful on Windows, where Ctrl-C or the terminal close box won't properly clean up). Since a PC can only have ony keyboard, ARIA keeps an <a class="el" href="classArKeyHandler.html">ArKeyHandler</a> pointer globally, which may be queried with <a class="el" href="classAria.html#e18">Aria::getKeyHandler()</a>.<p>
<dl compact><dt><b>Note:</b></dt><dd>if you are using Linux, creating a key handler will make the program hang if put into the background with Ctrl-Z.</dd></dl>
ARIA provides two simple actions, <a class="el" href="classArActionKeydrive.html">ArActionKeydrive</a> and <a class="el" href="classArActionJoydrive.html">ArActionJoydrive</a>, to drive a robot from keyboard and joystick input. These actions are used by the <a class="el" href="teleopActionsExample_8cpp-example.html">teleopActionsExample::cpp</a> example program. ARIA also provides a more flexible <a class="el" href="classArActionRatioInput.html">ArActionRatioInput</a>, which can combine several input sources (such as keyboard, computer joystick, robot-platform (microcontroller) joystick, or teleoperation commands recieved via ArNetworking) in a more consistent and configurable manner. See the class documentation for more details.<h2><a class="anchor" name="threading">
Threading</a></h2>
ARIA is highly multi-threaded. This section presents some of the critical concepts behind writing threaded ARIA code.<p>
ARIA provides a number of support classes to make it easier to write object-oriented threaded code. They are: <a class="el" href="classArASyncTask.html">ArASyncTask</a>, <a class="el" href="classArCondition.html">ArCondition</a>, <a class="el" href="classArMutex.html">ArMutex</a>, and <a class="el" href="classArThread.html">ArThread</a>.<p>
Thread-safe code mostly means proper coordination between threads when handling the same data. You want to avoid the problem of one or more threads reading or writing the data at the same time that other threads read or write the data. data. To prevent this problem from happening, the data needs to be protected with synchronization objects.<h3><a class="anchor" name="syncObject">
Thread Syncronizing Objects</a></h3>
In ARIA, the synchronization objects are <a class="el" href="classArMutex.html">ArMutex</a> and <a class="el" href="classArCondition.html">ArCondition</a>. <a class="el" href="classArMutex.html">ArMutex</a> is the most useful one. <a class="el" href="classArMutex.html">ArMutex</a> (<em>mutex</em> is short for <em>mut</em>ual <em>ex</em>clusion.) provides a wrapper around system calls (pthreads functions on Linux and CriticalSection functions on Windows) that exclude other threads from continuing while the mutex object is "locked". When threads lock a mutex while accessing shared data, it is ensured that only one thread is accessing that shared data at a time. Therefore, the proper way to use a mutex is to lock it right before accessing the shared data, and to always unlock it when done. If the mutex is not already locked, then it becomes locked and the thread continues. If the mutex is already locked by another thread, then it blocks in the lock call until the other thread unlocks it. If a mutex is never unlocked (e.g. a function returns due to an error condition without unlocking it), then any further attempts to lock it will block forever, creating a "deadlock". See the mutex example program to see how <a class="el" href="classArMutex.html">ArMutex</a> is used. The documentation of a method may indicate whether locking is necessary before using it; in general, when using an object that may be shared by other threads, all threads using it must lock the same mutex (usually contained within the object's class with methods provided for locking and unlocking) while using the object.<p>
<a class="el" href="classArCondition.html">ArCondition</a> is an occasionally used utility that puts the current thread to sleep until another thread signals it to wake up and continue executing. This can be used to wait in a thread for an indefinite amount of time until some event occurs in a another thread which signals the <a class="el" href="classArCondition.html">ArCondition</a>.<h3><a class="anchor" name="asynctasks">
Asynchronous Task Class</a></h3>
ARIA provides the <a class="el" href="classArASyncTask.html">ArASyncTask</a> which can be subclassed to implement a long-running thread and its state as an object. As opposed to robot-syncronized tasks, asynchronous tasks run in seperate threads. Like <a class="el" href="classArMutex.html">ArMutex</a>, this class wraps the operating system's threading calls in a cross-platform way. Typically, an <a class="el" href="classArASyncTask.html">ArASyncTask</a> will reperesent a thread that runs in a loop for the entire program.<p>
To use <a class="el" href="classArASyncTask.html">ArASyncTask</a>, derive a class from <a class="el" href="classArASyncTask.html">ArASyncTask</a> and override the <a class="el" href="classArASyncTask.html#a6">ArASyncTask::runThread()</a> function. This function is automatically called within the new thread when that new thread gets created. To create and start the thread, call <a class="el" href="classArASyncTask.html#a1">ArASyncTask::create()</a>. When the <a class="el" href="classArASyncTask.html#a6">ArASyncTask::runThread()</a> function exits, the thread will exit and be destroyed. Seperate threads can request that the task exit by calling <a class="el" href="classArASyncTask.html#a7">ArASyncTask::stopRunning()</a>, and within the thread, you can check for this request with <a class="el" href="classArThread.html#a12">ArASyncTask::getRunningWithLock()</a>.<p>
This class is mainly a convenience wrapper around <a class="el" href="classArThread.html">ArThread</a> so that you can easily create your own object that encapsulates the concept of a thread.<h2><a class="anchor" name="aria">
Global Data</a></h2>
The static <a class="el" href="classAria.html">Aria</a> class contains miscellaneous global data in ARIA.<p>
ARIA contains a list of all the <a class="el" href="classArRobot.html">ArRobot</a> instances. Use the <a class="el" href="classAria.html#e13">Aria::findRobot()</a> to find a robot by name, or use <a class="el" href="classAria.html#e21">Aria::getRobotList()</a> to get a list of the robots.<p>
Use <a class="el" href="classAria.html#e15">Aria::getDirectory()</a> to find ARIA's top-level path (Usually either <code>C:\Program Files\MobileRobots\Aria</code> on Windows, or <code>/usr/local/Aria</code> on Linux). This is useful, for instance, to locate robot parameter files for individual operational details. Use <a class="el" href="classAria.html#e30">Aria::setDirectory()</a> to change this path for the run of the program if you feel the need to override what ARIA has decided.<p>
Call <a class="el" href="classAria.html#e23">Aria::init()</a> at program start to perform global initialization, and use <a class="el" href="classAria.html#e11">Aria::exit()</a> to exit all ARIA threads before exiting your program.<p>
The <a class="el" href="classAria.html">Aria</a> class also contains global objects for sharing configuration parameters and other information: see <a class="el" href="main.html#arconfig">ArConfig</a> and <a class="el" href="main.html#arinfogroup">Shared Info Groups</a> sections below.<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="main.html#arconfig">ArConfig</a> <p>
<a class="el" href="main.html#arinfogroup">Shared Info Groups</a></dd></dl>
<h2><a class="anchor" name="devices">
Device and Accessory Interface Classes</a></h2>
ARIA includes classes to communicate with various kinds of devices.<p>
(Many of these devices are optional accessories, and not all robots have them installed.)<p>
<ul>
<li>
Range devices. See <a class="el" href="main.html#rangeDevices">Range Devices</a> for more about range devices. <ul>
<li>
subclasses of <a class="el" href="classArLaser.html">ArLaser</a> for the laser rangefinders. Use <a class="el" href="classArLaserConnector.html">ArLaserConnector</a> to automatically create and set up <a class="el" href="classArLaser.html">ArLaser</a> objects of the appropriate types based on robot and program configuration parameters. </li>
<li>
<a class="el" href="classArSonarDevice.html">ArSonarDevice</a> for Pioneer and Amigobot built-in sonar. </li>
<li>
<a class="el" href="classArBumpers.html">ArBumpers</a> treats the robot's bumper switch triggers as positions for range device readings. </li>
<li>
ArRangeDeviceFilter provides an <a class="el" href="classArRangeDevice.html">ArRangeDevice</a> interface to data from any other range device that has been filtered in different ways. </li>
<li>
<a class="el" href="classArForbiddenRangeDevice.html">ArForbiddenRangeDevice</a> is a virtual range device that returns readings indicating the edges of forbidden lines and forbidden areas from an <a class="el" href="classArMap.html">ArMap</a> </li>
<li>
<a class="el" href="classArIRs.html">ArIRs</a> treats triggers of a Peoplebot's infrared "table" sensors as positions for range device readings. </li>
</ul>
devices <p>
</li>
<li>
Pan/Tilt servos and camera bases. <a class="el" href="classArPTZ.html">ArPTZ</a> defines a common interface, and subclasses access specific devices, including: <ul>
<li>
<a class="el" href="classArVCC4.html">ArVCC4</a> provides pan, tilt, zoom and other control of a Canon camera via the robot microcontroller's AUX serial port. </li>
<li>
<a class="el" href="classArSonyPTZ.html">ArSonyPTZ</a> provides pan, tilt, zoom and other actions of a Sony camera via the robot microcontroller's AUX serial port. </li>
<li>
<a class="el" href="classArDPPTU.html">ArDPPTU</a> provides control of a Directed Perceptions Pan/Tilt unit (used for stereo cameras). </li>
</ul>
<p>
</li>
<li>
<a class="el" href="classArAnalogGyro.html">ArAnalogGyro</a> enables a robot's on-board gyro, if present and enabled in the firmware configuration, after <a class="el" href="classArRobot.html">ArRobot</a> connects, and automatically corrects the heading component of ArRobot's pose value as new data is received. The gyro also measures its own temperature as part of its operation, and <a class="el" href="classArAnalogGyro.html">ArAnalogGyro</a> makes that value available as well, which can be used to detect damaging high-heat conditions in the robot electronics.<p>
</li>
<li>
<a class="el" href="classArGripper.html">ArGripper</a> provides access to a Pioneer gripper.<p>
</li>
<li>
<a class="el" href="classArP2Arm.html">ArP2Arm</a> provides access to a Pioneer arm.<p>
</li>
<li>
<a class="el" href="classArTCM2.html">ArTCM2</a> provides access to an on-board TCM2 compass, if present.<p>
</li>
<li>
<a class="el" href="classArACTS__1__2.html">ArACTS_1_2</a> communicates with the ACTS program to get object tracking information.<p>
</li>
<li>
<a class="el" href="classArVersalogicIO.html">ArVersalogicIO</a> provides access to the digital and analog I/O ports on Versalogic motherboards (Linux only). (Support depends on whether the robot has a Versalogic motherboard, and which board it has.) <p>
</li>
<li>
<a class="el" href="classArSystemStatus.html">ArSystemStatus</a> provides data about the operating system (Linux only) such as CPU usage and wireless network signal strength. <p>
</li>
<li>
<a class="el" href="classArGPS.html">ArGPS</a> provides access to data received from a Global Positioning System device. Subclasses implement special actions required for specific devices, such as <a class="el" href="classArNovatelGPS.html">ArNovatelGPS</a> for the NovAtel G2 and similar devices and <a class="el" href="classArTrimbleGPS.html">ArTrimbleGPS</a> for the Trimble GPS. Use <a class="el" href="classArGPSConnector.html">ArGPSConnector</a> to create the appropriate <a class="el" href="classArGPS.html">ArGPS</a> device based on robot and program configuration parameters.  </li>
</ul>
<p>
Some device interfaces are provided by additional libraries, as well. See those libraries for details.<h2><a class="anchor" name="utility">
Utility Classes</a></h2>
Some of the general-purpose utility classes included with are <a class="el" href="classArMath.html">ArMath</a>, <a class="el" href="classArUtil.html">ArUtil</a>, <a class="el" href="classArTime.html">ArTime</a>, <a class="el" href="classArPose.html">ArPose</a>, <a class="el" href="classArLog.html">ArLog</a>, <a class="el" href="classArSectors.html">ArSectors</a>, <a class="el" href="classArRingQueue.html">ArRingQueue</a>, <a class="el" href="classArLineFinder.html">ArLineFinder</a>, the GPS-related subclasses of ArPoint3d, <a class="el" href="classArMD5Calculator.html">ArMD5Calculator</a> (and the functions in <a class="el" href="md5_8h.html">md5.h</a>), <a class="el" href="classArMutex.html">ArMutex</a>, <a class="el" href="classArCondition.html">ArCondition</a> and <a class="el" href="classArASyncTask.html">ArASyncTask</a>. See those classes for further information.<h2><a class="anchor" name="arconfig">
ArConfig</a></h2>
<a class="el" href="classArConfig.html">ArConfig</a> is a mechanism for storing configuration parameters for different independent modules in a text file. The global <a class="el" href="classAria.html">Aria</a> class maintains a global <a class="el" href="classArConfig.html">ArConfig</a> pointer which any program module may access. Use <a class="el" href="classArConfig.html#a1">ArConfig::addParam</a> to register a new parameter with <a class="el" href="classArConfig.html">ArConfig</a>, and use <a class="el" href="classArConfig.html#a3">ArConfig::addProcessFileCB</a> to register a callback functor called when the configuration changes (by loading the file with <a class="el" href="classArConfig.html#a23">ArConfig::parseFile</a>, or other means such as an update from a remote client via ArNetworking).<h2><a class="anchor" name="arinfogroup">
Shared Info Groups</a></h2>
In a program composed of multiple independent modules, it is often necessary to exchange or combine data between them in a general and immediate way. To do this, ARIA provides the <a class="el" href="classArStringInfoGroup.html">ArStringInfoGroup</a> class, of which the global ARIA class contains an instance (in addition to an <a class="el" href="classArConfig.html">ArConfig</a> instance used specifically for configuration information which changes infrequently, by loading a file or by user input.) An example of <a class="el" href="classArStringInfoGroup.html">ArStringInfoGroup</a> is the ArServerInfoStrings class contained in the ArNetworking auxiliary library. At program initialization, a callback functor may be added to the global <a class="el" href="classArStringInfoGroup.html">ArStringInfoGroup</a> object which on invocation immediately passes a string key/value pair from the <a class="el" href="classArStringInfoGroup.html">ArStringInfoGroup</a> object over to an ArServerInfoStrings object, which provides access to this data over the network (e.g. to MobileEyes). Independent components of the program may then change the values in the InfoGroup object without needing any special knowledge of the recipients of the data (in this example is the ArServerInfoStrings class). Since MobileEyes displays this data in a small table next to other robot information like position in speed, this is a useful way to provide informative statistics about the robot and software's current operation. (On Linux, for example, you could use the <a class="el" href="classArSystemStatus.html">ArSystemStatus</a> class to publish information from the operating system, like CPU load).<h2><a class="anchor" name="maps">
Maps</a></h2>
In mobile robot applications, you will often need to store a map of the robot's environment to use in navigation, localization, etc. ARIA provides the <a class="el" href="classArMap.html">ArMap</a> class for reading map data from a file, obtaining and modifying its contents in your application, and writing it back to file. An <a class="el" href="classArMap.html">ArMap</a> contains data about the sensed/sensable environment (walls, obstacles, etc.), and human-provided objects such as goal points.<p>
The <a class="el" href="MapFileFormat.html">Map File Format</a> page describes the map file format in detail.<p>
ARNL, SONARNL and MobileSim all use <a class="el" href="classArMap.html">ArMap</a> format map files.<h2><a class="anchor" name="sockets">
Sockets</a></h2>
The <a class="el" href="classArSocket.html">ArSocket</a> class is a wrapper around the socket network communication layer of your operating system. ARIA mostly uses <a class="el" href="classArSocket.html">ArSocket</a> to open a server port and to connect to another server port.<p>
To connect to a port, simply construct a socket containing the hostname or IP address of the host, a port number, and the ARIA socket type (TCP or UDP). For example:<p>
<div class="fragment"><pre class="fragment">     <a class="code" href="classArSocket.html">ArSocket</a> sock(<span class="stringliteral">"host.name.com"</span>, 4040, ArSocket::TCP);
</pre></div><p>
Or call the <a class="el" href="classArSocket.html#a7">ArSocket::connect()</a> function, such as:<p>
<div class="fragment"><pre class="fragment">     <a class="code" href="classArSocket.html">ArSocket</a> sock;
     sock.<a class="code" href="classArSocket.html#a7">connect</a>(<span class="stringliteral">"host.name.com"</span>, 4040, ArSocket::TCP);
</pre></div><p>
To open a server on (for example) port 4040, simply construct a socket:<p>
<div class="fragment"><pre class="fragment">     <a class="code" href="classArSocket.html">ArSocket</a> sock(4040, <span class="keyword">true</span>, ArSocket::TCP);
</pre></div><p>
Or call <code>open(4040, ArSocket::TCP)</code> on an <a class="el" href="classArSocket.html">ArSocket</a> object constructed with the default constructor.<h2><a class="anchor" name="ArNetworking">
ArNetworking</a></h2>
For a more advanced networking infrastructure, see <a href="../ArNetworking/docs/index.html" target="_top" 
>the ArNetworking companion library</a>, distributed with ARIA. ArNetworking provides an extensible system of data requests and updates between client and server applications via TCP or UDP, using the same base "packet" concept as robot communication. For example, use ArNetworking to connect multiple robots working together, off-board user interfaces to on-board control servers, or robot control programs to off-board data resources.<h2><a class="anchor" name="sound">
Sound and Speech</a></h2>
ARIA provides foundation sound support, and separate libraries use this for speech and network audio.<p>
<ol>
<li>
ARIA's <a class="el" href="classArSoundsQueue.html">ArSoundsQueue</a> provides a method for handling sound output generated by various components of a large ARIA application in sequence and in loops. It is a sound playback and speech synthesis manager, which uses a thread-safe queue of sound and speech synthesis requests, and runs a background processing thread for it. Use this for most of your non-trivial audio playback and voice synthesis needs. The speech synthesis libraries, the voice recognition library, and the NetAudio library are designed to be used in conjunction with this class to coordinate their usage of the sound device. <p>
</li>
<li>
ARIA's <a class="el" href="classArSoundPlayer.html">ArSoundPlayer</a> provides a basic cross-platform sound-file playback capability. Sound files are in WAV (Windows RIFF) format. This class provides static methods that can be used by <a class="el" href="classArSoundsQueue.html">ArSoundsQueue</a> for sound file playback. <p>
</li>
<li>
Separate libraries provide wrappers around some speech synthesis (Text-to-speech) and recognition products: <ul>
<li>
The ArSpeechSynth_Festival library uses the free Festival system from the University of Edinburgh to perform speech synthesis. It provides the ArFestival class as a wrapper around Festival.  </li>
<li>
The ArSpeechSynth_Cepstral library uses the Swift library from Cepstral, Inc. to perform speech synthesis. It provides the ArCepstral class for this. ArCepstral offers a few extra features over ArFestival, and Cepstral, Inc. provides high quality voices for use with Swift.  </li>
<li>
The ArSpeechRec_Sphinx library uses Sphinx from Carnegie Mellon University to perform speech recognition. ArSphinx provides an interface to this.  </li>
</ul>
<p>
<p>
Functions common to both of the speech synthesis libraries are included in a base class, <a class="el" href="classArSpeechSynth.html">ArSpeechSynth</a>. <p>
</li>
<li>
The separate ArNetAudio library provides network voice audio recording, transmission and playback: <ul>
<li>
ArNetAudioServer automatically decodes and plays or records and encodes audio for a network server (typically running on a robot's on-board computer) and sends and receives the encoded audio to/from a client. </li>
<li>
ArNetAudioClient automatically decodes and plays or records and encodes audio for a network client, sending and receiving the encoded audio to/from a server (i.e. a robot's on-board computer). </li>
<li>
ArNetAudioIO is the common class performing cross-platform Audio I/O (via the free PortAudio library), and voice encoding/decoding (via the free Speex codec). It is used by ArNetAudioClient and ArNetAudioServer, but is also available for stand alone use.  </li>
</ul>
<p>
</li>
</ol>
<h2><a class="anchor" name="emacs">
Emacs</a></h2>
Here is the configuration specification the developers at MobileRobots Inc. use in their .emacs files, in case you want to modify the code using emacs and not deal with differences in indentation and such.<p>
<pre>
    (setq c-default-style '((other . "user")))
    (c-set-offset 'substatement-open 0)
    (c-set-offset 'defun-block-intro 2)
    (c-set-offset 'statement-block-intro 2)
    (c-set-offset 'substatement 2)
    (c-set-offset 'topmost-intro -2)
    (c-set-offset 'arglist-intro '++)
    (c-set-offset 'statement-case-intro '*)
    (c-set-offset 'member-init-intro 2)
    (c-set-offset 'inline-open 0)
    (c-set-offset 'brace-list-intro 2)
    (c-set-offset 'statement-cont 0)
    (defvar c-mode-hook 'c++-mode)
</pre><h2><a class="anchor" name="noneverydayC">
Non-everyday use of C++</a></h2>
ARIA uses some features of C++ that some programmers may not be aware of yet, and includes some workarounds for platform differences.<h3><a class="anchor" name="stl">
Standard Template Library</a></h3>
ARIA makes heavy use of the C++ standard template library (STL). So you should understand the STL in order to get the best use from some of the more advanced parts of ARIA.<h3><a class="anchor" name="defaultArgs">
Default Arguments</a></h3>
In the function declaration a default value for an argument may be specified. Arguments with default values may then be omitted from the function call.<p>
For example, after declaring this function with a default value for its integer argument: <div class="fragment"><pre class="fragment">     <span class="keywordtype">void</span> foo(<span class="keywordtype">int</span> number = 3);
</pre></div> it can be used in two different ways: <div class="fragment"><pre class="fragment">     <span class="comment">// Use the default value for the argument:</span>
     foo();

     <span class="comment">// Or, use don't use the default:</span>
     foo(99);   
</pre></div><p>
This behavior is quite useful for having defaults for more obscure options you will usually not need to change, but still allowing you to change them if necessary without making ARIA more complex.<p>
Also note that the function definition must not have the assignment in it, only the declaration. Therefore the definition if our example function would look like this: <div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> foo(<span class="keywordtype">int</span> number)
  { 
    <span class="comment">//...</span>
  }
</pre></div><h3><a class="anchor" name="constructorChaining">
Constructor Chaining</a></h3>
Constructor chaining is quite simple though sometimes not used by C++ programmers. Each constructor can give arguments to the constructors of the member variables it contains and to the constructors of classes from which it inherits. For example if you have:<p>
<div class="fragment"><pre class="fragment">     <span class="keyword">class </span>BaseClass
     {
     <span class="keyword">public</span>:
       BaseClass(<span class="keywordtype">int</span> someNumber);
     };
</pre></div> and <div class="fragment"><pre class="fragment">     <span class="keyword">class </span>SubClass : <span class="keyword">public</span> BaseClass
     {
     <span class="keyword">public</span>:
       SubClass(<span class="keywordtype">void</span>);
       <span class="keywordtype">int</span> anotherNumber;
     };
</pre></div> When you write your constructor for SubClass you can initialize both baseClass and anotherNumber: <div class="fragment"><pre class="fragment">     SubClass::SubClass(<span class="keywordtype">void</span>) : BaseClass(3), anotherNumber(37)
     {
         <span class="comment">// ...</span>
     }
</pre></div> Note how the constructors to be initialized must follow a colon (:) after the constructor, and be separated by commas. Member variables must be initialized in the order they are in the class. Note that initializing integers is not all that unique or useful, but using this to initialize callback <a class="el" href="main.html#functors">Functors</a> is quite useful.<p>
Constructor chaining is used in many many places by ARIA, thus it must be understood in order to understand ARIA, but the above is all that really needs to be known.<h3><a class="anchor" name="charsAndStrings">
Chars and Strings, Win workaround</a></h3>
During development problems were encountered with Windows if a <code>std::string</code> was passed into a DLL. Thus for all input to ARIA <code>const char *</code> is used, but for all internal storage and all reporting <code>std::string</code>s are passed back out of ARIA.<h3><a class="anchor" name="arexport">
AREXPORT</a></h3>
Because of the Windows set up for using DLLs, this macro is used to take care of the required declaration attributes for DLLs. Largely users do not need to worry about <code>AREXPORT</code>, but only functions which have <code>AREXPORT</code> and inline functions are usable with DLLs in Windows (all of the ARIA functions which are documented in this manual are usable).<h3><a class="anchor" name="exceptions">
Exceptions</a></h3>
ARIA neither throws nor catches any exceptions.<h2><a class="anchor" name="Advanced">
Topics and Esoterica</a></h2>
<h3><a class="anchor" name="pieceMealUse">
Piecemeal Use of ARIA</a></h3>
The most basic layer of ARIA is <a class="el" href="classArDeviceConnection.html">ArDeviceConnection</a> and subclasses, which handle low-level communication with the robot server. On top of the connection layer, we have a packet layer--ArBasePacket and ArRobotPacket--the basic algorithms for constructing command packets and decoding server information packets.<p>
Above the packet layer is the packet handler classes, <a class="el" href="classArRobotPacketReceiver.html">ArRobotPacketReceiver</a> and <a class="el" href="classArRobotPacketSender.html">ArRobotPacketSender</a>, when send and receive packets to and from the robot. Finally, on top of all these lowest layers is <a class="el" href="classArRobot.html">ArRobot</a>, which is a gathering point for all things, but can be used in a quite basic format without all of the bells and whistles. <a class="el" href="classArRobot.html">ArRobot</a> has built-in tasks, actions, state reflection and so forth, all of which can be disabled from the constructor (<a class="el" href="classArRobot.html#a17">ArRobot::ArRobot</a>) and ignored or reimplemented.<p>
Also note that if all you do is turn off state reflection, which only affects sending ArRobot-mediated motion commands to the robot, not receiving SIPs from the robot, none of the other activities which <a class="el" href="classArRobot.html">ArRobot</a> engages on its loop will take up hardly any time, so it probably isn't worth building your own set of tasks, but the power to do so is there for the intrepid.<p>
One other thing worth noting is that you can call <a class="el" href="classArRobot.html#a221">ArRobot::loopOnce()</a> and it will run through its loop a single time and return. This is so that you can use ARIA from your own control structure. If you are using loopOnce you may also find it beneficial to call <a class="el" href="classArRobot.html#a197">ArRobot::incCounter</a>, so that the loop counter will be updated. You could also just call <a class="el" href="classArRobot.html#a226">ArRobot::packetHandler</a>, <a class="el" href="classArRobot.html#a0">ArRobot::actionHandler</a>, or <a class="el" href="classArRobot.html#a323">ArRobot::stateReflector</a> on your own, as these are the most important internal functions, though if you make your own loop you should probably call <a class="el" href="classArRobot.html#a197">ArRobot::incCounter</a> any way that you do it, as this is how sonar are known to be new or not, and such.<p>
We recommend that whatever you do you use the same type of strict threading/locking that ARIA observes.<h3><a class="anchor" name="hardConnectRobot">
Connecting with a Robot or the Simulator the hard way</a></h3>
<a class="el" href="classArDeviceConnection.html">ArDeviceConnection</a> is ARIA's communications object; <a class="el" href="classArSerialConnection.html">ArSerialConnection</a> and <a class="el" href="classArTcpConnection.html">ArTcpConnection</a> are its built-in children most commonly used to manage communication between a MobileRobots or ActivMedia robot or the robot simulator, respectively. These classes are not device-specific, however, so use <a class="el" href="classArSerialConnection.html">ArSerialConnection</a>, for instance, to also configure a serial port and establish a connection with a robot accessory, such as with the SICK laser range finder.<h3><a class="anchor" name="openDevice">
Opening the Connection</a></h3>
After creating and opening a device connection, associate it with its ARIA device handlers, most commonly with <a class="el" href="classArRobot.html#a275">ArRobot::setDeviceConnection</a> for the robot or the simulator.<p>
For example, early in an ARIA program, specify the connection device and associate it with the robot:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classArTcpConnection.html">ArTcpConnection</a> con;
  <a class="code" href="classArRobot.html">ArRobot</a> robot;
</pre></div><p>
Later in the program, after initializing the ARIA system (<a class="el" href="classAria.html#e23">Aria::init()</a>; is mandatory), set the Connection port to its default values (for TCP, host is "localhost" and port number is 8101), and then open the port:<p>
<div class="fragment"><pre class="fragment"> con.<a class="code" href="classArTcpConnection.html#a13">setPort</a>();
 <span class="keywordflow">if</span> (!con.<a class="code" href="classArTcpConnection.html#a11">openSimple</a>())
  {
    printf(<span class="stringliteral">"Open failed."</span>);
    <a class="code" href="classAria.html#e37">Aria::shutdown</a>();
    <span class="keywordflow">return</span> 1;
  }
</pre></div><p>
TCP and Serial connections have their own implementation of open which is not inherited, but has default arguments that make the generic open work for the all default cases. And open returns a status integer which can be passed to the re-implemented and inherited <a class="el" href="classArDeviceConnection.html#a2">ArDeviceConnection::getOpenMessage</a> in order to retrieve related status string, which is useful in reporting errors to the user without having to know about the underlying device.<h3><a class="anchor" name="devConnect">
Robot Client-Server Connection</a></h3>
After associating the device with the robot, now connect with the robot's servers, <a class="el" href="classArRobot.html#a21">ArRobot::blockingConnect</a> or <a class="el" href="classArRobot.html#a18">ArRobot::asyncConnect</a>, for example, to establish the client-server connection between ARIA <a class="el" href="classArRobot.html">ArRobot</a> and the robot microcontroller or robot simulator. The blockingConnect method doesn't return from the call until a connection succeeds or fails:<p>
<div class="fragment"><pre class="fragment">  robot.<a class="code" href="classArRobot.html#a275">setDeviceConnection</a>(&amp;con);
  <span class="keywordflow">if</span> (!robot.<a class="code" href="classArRobot.html#a21">blockingConnect</a>())
  {
    printf(<span class="stringliteral">"Could not connect to robot... Exiting."</span>);
    <a class="code" href="classAria.html#e37">Aria::shutdown</a>();
    <span class="keywordflow">return</span> 1;
  }
</pre></div><p>
The previous examples connect with the simulator through a TCP socket on your PC. Use <code>tcpConn.setPort(host, port)</code> to set the TCP hostname or IP address and related socket number to another machine on the network. For instance, use <code>tcpConn.setPort("bill", 8101);</code> to connect to the simulator which is running on the networked computer "bill" through port 8101.<p>
Replace <code><a class="el" href="classArTcpConnection.html">ArTcpConnection</a> con;</code> with <code><a class="el" href="classArSerialConnection.html">ArSerialConnection</a> con;</code> to connect with a robot through the default serial port (<code>/dev/ttyS0</code> or <code>COM1</code>), or another you specify with <a class="el" href="classArSerialConnection.html#a19">ArSerialConnection::setPort()</a>, such as <code>con.setPort("COM3");</code>.<p>
At some point, you may want to open the port with the more verbose <code>con.open()</code>.<h3><a class="anchor" name="connrw">
Connection Read, Write, Close and Timestamping</a></h3>
The two main functions of a device connection are <a class="el" href="classArDeviceConnection.html#a8">ArDeviceConnection::read</a> and <a class="el" href="classArDeviceConnection.html#a9">ArDeviceConnection::write</a>. Simple enough. <a class="el" href="classArDeviceConnection.html#a1">ArDeviceConnection::close</a> also is inherited and important. You probably won't use direct read or write to the robot device, although you could. Rather, <a class="el" href="classArRobot.html">ArRobot</a> provides a host of convenient methods that package your robot commands, and gather and distribute the various robot information packets, so that you don't have to attend those mundane details. See the next section for details.<p>
All <a class="el" href="classArDeviceConnection.html">ArDeviceConnection</a> subclasses have support for timestamping (<a class="el" href="classArDeviceConnection.html#a5">ArDeviceConnection::getTimeRead</a>). With the robot connection, timestamping merely says what time a robot SIP came in, which can be useful for interpolating the robot's location more precisely. <hr size="1"><address style="align: right;"><small>Generated on Thu Jan 7 10:34:37 2010 for Aria by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
